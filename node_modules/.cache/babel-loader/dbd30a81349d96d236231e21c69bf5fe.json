{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('./utils');\n\nconst sequelizeError = require('./errors');\n\nconst DataTypes = require('./data-types');\n\nconst BelongsTo = require('./associations/belongs-to');\n\nconst validator = require('./utils/validator-extras').validator;\n\nconst {\n  promisify\n} = require('util');\n/**\n * Instance Validator.\n *\n * @param {Instance} modelInstance The model instance.\n * @param {object} options A dictionary with options.\n *\n * @private\n */\n\n\nclass InstanceValidator {\n  constructor(modelInstance, options) {\n    options = {\n      // assign defined and default options\n      hooks: true,\n      ...options\n    };\n\n    if (options.fields && !options.skip) {\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    } else {\n      options.skip = options.skip || [];\n    }\n\n    this.options = options;\n    this.modelInstance = modelInstance;\n    /**\n     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`\n     *\n     * @name validator\n     * @private\n     */\n\n    this.validator = validator;\n    /**\n     *  All errors will be stored here from the validations.\n     *\n     * @type {Array} Will contain keys that correspond to attributes which will\n     *   be Arrays of Errors.\n     * @private\n     */\n\n    this.errors = [];\n    /**\n     * @type {boolean} Indicates if validations are in progress\n     * @private\n     */\n\n    this.inProgress = false;\n  }\n  /**\n   * The main entry point for the Validation module, invoke to start the dance.\n   *\n   * @returns {Promise}\n   * @private\n   */\n\n\n  async _validate() {\n    if (this.inProgress) throw new Error('Validations already in progress.');\n    this.inProgress = true;\n    await Promise.all([this._perAttributeValidators(), this._customValidators()]);\n\n    if (this.errors.length) {\n      throw new sequelizeError.ValidationError(null, this.errors);\n    }\n  }\n  /**\n   * Invoke the Validation sequence and run validation hooks if defined\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n\n\n  async validate() {\n    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());\n  }\n  /**\n   * Invoke the Validation sequence and run hooks\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n\n\n  async _validateAndRunHooks() {\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    await runHooks('beforeValidate', this.modelInstance, this.options);\n\n    try {\n      await this._validate();\n    } catch (error) {\n      const newError = await runHooks('validationFailed', this.modelInstance, this.options, error);\n      throw newError || error;\n    }\n\n    await runHooks('afterValidate', this.modelInstance, this.options);\n    return this.modelInstance;\n  }\n  /**\n   * Will run all the validators defined per attribute (built-in validators and custom validators)\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n\n\n  async _perAttributeValidators() {\n    // promisify all attribute invocations\n    const validators = [];\n\n    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\n      if (this.options.skip.includes(field)) {\n        return;\n      }\n\n      const value = this.modelInstance.dataValues[field];\n\n      if (value instanceof Utils.SequelizeMethod) {\n        return;\n      }\n\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n        // perform validations based on schema\n        this._validateSchema(rawAttribute, field, value);\n      }\n\n      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {\n        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));\n      }\n    });\n\n    return await Promise.all(validators);\n  }\n  /**\n   * Will run all the custom validators defined in the model's options.\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n\n\n  async _customValidators() {\n    const validators = [];\n\n    _.each(this.modelInstance.constructor.options.validate, (validator, validatorType) => {\n      if (this.options.skip.includes(validatorType)) {\n        return;\n      }\n\n      const valprom = this._invokeCustomValidator(validator, validatorType) // errors are handled in settling, stub this\n      .catch(() => {});\n\n      validators.push(valprom);\n    });\n\n    return await Promise.all(validators);\n  }\n  /**\n   * Validate a single attribute with all the defined built-in validators and custom validators.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {string} field The field name.\n   * @param {boolean} allowNull Whether or not the schema allows null values\n   *\n   * @returns {Promise} A promise, will always resolve, auto populates error on this.error local object.\n   */\n\n\n  async _singleAttrValidate(value, field, allowNull) {\n    // If value is null and allowNull is false, no validators should run (see #9143)\n    if ((value === null || value === undefined) && !allowNull) {\n      // The schema validator (_validateSchema) has already generated the validation error. Nothing to do here.\n      return;\n    } // Promisify each validator\n\n\n    const validators = [];\n\n    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {\n      if (validatorType === 'isUrl' || validatorType === 'isURL' || validatorType === 'isEmail') {\n        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object\n        if (typeof test === 'object' && test !== null && test.msg) {\n          test = {\n            msg: test.msg\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      } // Custom validators should always run, except if value is null and allowNull is false (see #9143)\n\n\n      if (typeof test === 'function') {\n        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));\n        return;\n      } // If value is null, built-in validators should not run (only custom validators have to run) (see #9134).\n\n\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field); // errors are handled in settling, stub this\n\n\n      validatorPromise.catch(() => {});\n      validators.push(validatorPromise);\n    });\n\n    return Promise.all(validators.map(validator => validator.catch(rejection => {\n      const isBuiltIn = !!rejection.validatorName;\n\n      this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);\n    })));\n  }\n  /**\n   * Prepare and invoke a custom validator.\n   *\n   * @private\n   *\n   * @param {Function} validator The custom validator.\n   * @param {string} validatorType the custom validator type (name).\n   * @param {boolean} optAttrDefined Set to true if custom validator was defined from the attribute\n   * @param {*} optValue value for attribute\n   * @param {string} optField field for attribute\n   *\n   * @returns {Promise} A promise.\n   */\n\n\n  async _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {\n    let isAsync = false;\n    const validatorArity = validator.length; // check if validator is async and requires a callback\n\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n\n    if (isAsync) {\n      try {\n        if (optAttrDefined) {\n          return await promisify(validator.bind(this.modelInstance, invokeArgs))();\n        }\n\n        return await promisify(validator.bind(this.modelInstance))();\n      } catch (e) {\n        return this._pushError(false, errorKey, e, optValue, validatorType);\n      }\n    }\n\n    try {\n      return await validator.call(this.modelInstance, invokeArgs);\n    } catch (e) {\n      return this._pushError(false, errorKey, e, optValue, validatorType);\n    }\n  }\n  /**\n   * Prepare and invoke a build-in validator.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated\n   *\n   * @returns {object} An object with specific keys to invoke the validator.\n   */\n\n\n  async _invokeBuiltinValidator(value, test, validatorType, field) {\n    // Cast value as string to pass new Validator.js string requirement\n    const valueString = String(value); // check if Validator knows that kind of validation test\n\n    if (typeof validator[validatorType] !== 'function') {\n      throw new Error(`Invalid validator function: ${validatorType}`);\n    }\n\n    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n\n    if (!validator[validatorType](valueString, ...validatorArgs)) {\n      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), {\n        validatorName: validatorType,\n        validatorArgs\n      });\n    }\n  }\n  /**\n   * Will extract arguments for the validator.\n   *\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated.\n   *\n   * @private\n   */\n\n\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator = typeof validatorArgs !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');\n\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === 'isImmutable') {\n        validatorArgs = [validatorArgs, field, this.modelInstance];\n      } else if (isLocalizedValidator || validatorType === 'isIP') {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = validatorArgs.slice(0);\n    }\n\n    return validatorArgs;\n  }\n  /**\n   * Will validate a single field against its schema definition (isnull).\n   *\n   * @param {object} rawAttribute As defined in the Schema.\n   * @param {string} field The field name.\n   * @param {*} value anything.\n   *\n   * @private\n   */\n\n\n  _validateSchema(rawAttribute, field, value) {\n    if (rawAttribute.allowNull === false && (value === null || value === undefined)) {\n      const association = Object.values(this.modelInstance.constructor.associations).find(association => association instanceof BelongsTo && association.foreignKey === rawAttribute.fieldName);\n\n      if (!association || !this.modelInstance.get(association.associationAccessor)) {\n        const validators = this.modelInstance.validators[field];\n\n        const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);\n\n        this.errors.push(new sequelizeError.ValidationErrorItem(errMsg, 'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n        field, value, this.modelInstance, 'is_null'));\n      }\n    }\n\n    if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {\n      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n        this.errors.push(new sequelizeError.ValidationErrorItem(`${field} cannot be an array or an object`, 'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n        field, value, this.modelInstance, 'not_a_string'));\n      }\n    }\n  }\n  /**\n   * Signs all errors retaining the original.\n   *\n   * @param {boolean}       isBuiltin   - Determines if error is from builtin validator.\n   * @param {string}        errorKey    - name of invalid attribute.\n   * @param {Error|string}  rawError    - The original error.\n   * @param {string|number} value       - The data that triggered the error.\n   * @param {string}        fnName      - Name of the validator, if any\n   * @param {Array}         fnArgs      - Arguments for the validator [function], if any\n   *\n   * @private\n   */\n\n\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n    const message = rawError.message || rawError || 'Validation error';\n    const error = new sequelizeError.ValidationErrorItem(message, 'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,\n    errorKey, value, this.modelInstance, fnName, isBuiltin ? fnName : undefined, isBuiltin ? fnArgs : undefined);\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n    this.errors.push(error);\n  }\n\n}\n/**\n * The error key for arguments as passed by custom validators\n *\n * @type {string}\n * @private\n */\n\n\nInstanceValidator.RAW_KEY_NAME = 'original';\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports.default = InstanceValidator;","map":{"version":3,"sources":["/home/nawan44/Documents/github/portofolio/CRUD/node_modules/sequelize/lib/instance-validator.js"],"names":["_","require","Utils","sequelizeError","DataTypes","BelongsTo","validator","promisify","InstanceValidator","constructor","modelInstance","options","hooks","fields","skip","difference","Object","keys","rawAttributes","errors","inProgress","_validate","Error","Promise","all","_perAttributeValidators","_customValidators","length","ValidationError","validate","_validateAndRunHooks","runHooks","bind","error","newError","validators","forIn","rawAttribute","field","includes","value","dataValues","SequelizeMethod","_autoGenerated","autoIncrement","_validateSchema","prototype","hasOwnProperty","call","push","_singleAttrValidate","allowNull","each","validatorType","valprom","_invokeCustomValidator","catch","undefined","test","msg","validatorPromise","_invokeBuiltinValidator","map","rejection","isBuiltIn","validatorName","_pushError","validatorArgs","optAttrDefined","optValue","optField","isAsync","validatorArity","asyncArity","errorKey","invokeArgs","e","valueString","String","_extractValidatorArgs","assign","args","isLocalizedValidator","Array","isArray","slice","association","values","associations","find","foreignKey","fieldName","get","associationAccessor","errMsg","name","ValidationErrorItem","type","STRING","TEXT","CITEXT","isObject","Buffer","isBuffer","isBuiltin","rawError","fnName","fnArgs","message","RAW_KEY_NAME","module","exports","default"],"mappings":"AAAA;;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,SAAD,CAArB;;AACA,MAAME,cAAc,GAAGF,OAAO,CAAC,UAAD,CAA9B;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAMI,SAAS,GAAGJ,OAAO,CAAC,2BAAD,CAAzB;;AACA,MAAMK,SAAS,GAAGL,OAAO,CAAC,0BAAD,CAAP,CAAoCK,SAAtD;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAgBN,OAAO,CAAC,MAAD,CAA7B;AAEA;;;;;;;;;;AAQA,MAAMO,iBAAN,CAAwB;AACtBC,EAAAA,WAAW,CAACC,aAAD,EAAgBC,OAAhB,EAAyB;AAClCA,IAAAA,OAAO,GAAG;AACR;AACAC,MAAAA,KAAK,EAAE,IAFC;AAGR,SAAGD;AAHK,KAAV;;AAMA,QAAIA,OAAO,CAACE,MAAR,IAAkB,CAACF,OAAO,CAACG,IAA/B,EAAqC;AACnCH,MAAAA,OAAO,CAACG,IAAR,GAAed,CAAC,CAACe,UAAF,CAAaC,MAAM,CAACC,IAAP,CAAYP,aAAa,CAACD,WAAd,CAA0BS,aAAtC,CAAb,EAAmEP,OAAO,CAACE,MAA3E,CAAf;AACD,KAFD,MAEO;AACLF,MAAAA,OAAO,CAACG,IAAR,GAAeH,OAAO,CAACG,IAAR,IAAgB,EAA/B;AACD;;AAED,SAAKH,OAAL,GAAeA,OAAf;AAEA,SAAKD,aAAL,GAAqBA,aAArB;AAEA;;;;;;;AAMA,SAAKJ,SAAL,GAAiBA,SAAjB;AAEA;;;;;;;;AAOA,SAAKa,MAAL,GAAc,EAAd;AAEA;;;;;AAIA,SAAKC,UAAL,GAAkB,KAAlB;AACD;AAED;;;;;;;;AAMA,QAAMC,SAAN,GAAkB;AAChB,QAAI,KAAKD,UAAT,EAAqB,MAAM,IAAIE,KAAJ,CAAU,kCAAV,CAAN;AAErB,SAAKF,UAAL,GAAkB,IAAlB;AAEA,UAAMG,OAAO,CAACC,GAAR,CAAY,CAChB,KAAKC,uBAAL,EADgB,EAEhB,KAAKC,iBAAL,EAFgB,CAAZ,CAAN;;AAKA,QAAI,KAAKP,MAAL,CAAYQ,MAAhB,EAAwB;AACtB,YAAM,IAAIxB,cAAc,CAACyB,eAAnB,CAAmC,IAAnC,EAAyC,KAAKT,MAA9C,CAAN;AACD;AACF;AAED;;;;;;;;;;;;AAUA,QAAMU,QAAN,GAAiB;AACf,WAAO,OAAO,KAAKlB,OAAL,CAAaC,KAAb,GAAqB,KAAKkB,oBAAL,EAArB,GAAmD,KAAKT,SAAL,EAA1D,CAAP;AACD;AAED;;;;;;;;;;;;AAUA,QAAMS,oBAAN,GAA6B;AAC3B,UAAMC,QAAQ,GAAG,KAAKrB,aAAL,CAAmBD,WAAnB,CAA+BsB,QAA/B,CAAwCC,IAAxC,CAA6C,KAAKtB,aAAL,CAAmBD,WAAhE,CAAjB;AACA,UAAMsB,QAAQ,CAAC,gBAAD,EAAmB,KAAKrB,aAAxB,EAAuC,KAAKC,OAA5C,CAAd;;AAEA,QAAI;AACF,YAAM,KAAKU,SAAL,EAAN;AACD,KAFD,CAEE,OAAOY,KAAP,EAAc;AACd,YAAMC,QAAQ,GAAG,MAAMH,QAAQ,CAAC,kBAAD,EAAqB,KAAKrB,aAA1B,EAAyC,KAAKC,OAA9C,EAAuDsB,KAAvD,CAA/B;AACA,YAAMC,QAAQ,IAAID,KAAlB;AACD;;AAED,UAAMF,QAAQ,CAAC,eAAD,EAAkB,KAAKrB,aAAvB,EAAsC,KAAKC,OAA3C,CAAd;AACA,WAAO,KAAKD,aAAZ;AACD;AAED;;;;;;;;AAMA,QAAMe,uBAAN,GAAgC;AAC9B;AACA,UAAMU,UAAU,GAAG,EAAnB;;AAEAnC,IAAAA,CAAC,CAACoC,KAAF,CAAQ,KAAK1B,aAAL,CAAmBQ,aAA3B,EAA0C,CAACmB,YAAD,EAAeC,KAAf,KAAyB;AACjE,UAAI,KAAK3B,OAAL,CAAaG,IAAb,CAAkByB,QAAlB,CAA2BD,KAA3B,CAAJ,EAAuC;AACrC;AACD;;AAED,YAAME,KAAK,GAAG,KAAK9B,aAAL,CAAmB+B,UAAnB,CAA8BH,KAA9B,CAAd;;AAEA,UAAIE,KAAK,YAAYtC,KAAK,CAACwC,eAA3B,EAA4C;AAC1C;AACD;;AAED,UAAI,CAACL,YAAY,CAACM,cAAd,IAAgC,CAACN,YAAY,CAACO,aAAlD,EAAiE;AAC/D;AACA,aAAKC,eAAL,CAAqBR,YAArB,EAAmCC,KAAnC,EAA0CE,KAA1C;AACD;;AAED,UAAIxB,MAAM,CAAC8B,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqC,KAAKtC,aAAL,CAAmByB,UAAxD,EAAoEG,KAApE,CAAJ,EAAgF;AAC9EH,QAAAA,UAAU,CAACc,IAAX,CAAgB,KAAKC,mBAAL,CAAyBV,KAAzB,EAAgCF,KAAhC,EAAuCD,YAAY,CAACc,SAApD,CAAhB;AACD;AACF,KAnBD;;AAqBA,WAAO,MAAM5B,OAAO,CAACC,GAAR,CAAYW,UAAZ,CAAb;AACD;AAED;;;;;;;;AAMA,QAAMT,iBAAN,GAA0B;AACxB,UAAMS,UAAU,GAAG,EAAnB;;AACAnC,IAAAA,CAAC,CAACoD,IAAF,CAAO,KAAK1C,aAAL,CAAmBD,WAAnB,CAA+BE,OAA/B,CAAuCkB,QAA9C,EAAwD,CAACvB,SAAD,EAAY+C,aAAZ,KAA8B;AACpF,UAAI,KAAK1C,OAAL,CAAaG,IAAb,CAAkByB,QAAlB,CAA2Bc,aAA3B,CAAJ,EAA+C;AAC7C;AACD;;AAED,YAAMC,OAAO,GAAG,KAAKC,sBAAL,CAA4BjD,SAA5B,EAAuC+C,aAAvC,EACd;AADc,OAEbG,KAFa,CAEP,MAAM,CAAE,CAFD,CAAhB;;AAIArB,MAAAA,UAAU,CAACc,IAAX,CAAgBK,OAAhB;AACD,KAVD;;AAYA,WAAO,MAAM/B,OAAO,CAACC,GAAR,CAAYW,UAAZ,CAAb;AACD;AAED;;;;;;;;;;;;;AAWA,QAAMe,mBAAN,CAA0BV,KAA1B,EAAiCF,KAAjC,EAAwCa,SAAxC,EAAmD;AACjD;AACA,QAAI,CAACX,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKiB,SAA7B,KAA2C,CAACN,SAAhD,EAA2D;AACzD;AACA;AACD,KALgD,CAOjD;;;AACA,UAAMhB,UAAU,GAAG,EAAnB;;AACAnC,IAAAA,CAAC,CAACoC,KAAF,CAAQ,KAAK1B,aAAL,CAAmByB,UAAnB,CAA8BG,KAA9B,CAAR,EAA8C,CAACoB,IAAD,EAAOL,aAAP,KAAyB;AAErE,UAAIA,aAAa,KAAK,OAAlB,IAA6BA,aAAa,KAAK,OAA/C,IAA0DA,aAAa,KAAK,SAAhF,EAA2F;AACzF;AACA,YAAI,OAAOK,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,IAArC,IAA6CA,IAAI,CAACC,GAAtD,EAA2D;AACzDD,UAAAA,IAAI,GAAG;AACLC,YAAAA,GAAG,EAAED,IAAI,CAACC;AADL,WAAP;AAGD,SAJD,MAIO,IAAID,IAAI,KAAK,IAAb,EAAmB;AACxBA,UAAAA,IAAI,GAAG,EAAP;AACD;AACF,OAXoE,CAarE;;;AACA,UAAI,OAAOA,IAAP,KAAgB,UAApB,EAAgC;AAC9BvB,QAAAA,UAAU,CAACc,IAAX,CAAgB,KAAKM,sBAAL,CAA4BG,IAA5B,EAAkCL,aAAlC,EAAiD,IAAjD,EAAuDb,KAAvD,EAA8DF,KAA9D,CAAhB;AACA;AACD,OAjBoE,CAmBrE;;;AACA,UAAIE,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKiB,SAAhC,EAA2C;AACzC;AACD;;AAED,YAAMG,gBAAgB,GAAG,KAAKC,uBAAL,CAA6BrB,KAA7B,EAAoCkB,IAApC,EAA0CL,aAA1C,EAAyDf,KAAzD,CAAzB,CAxBqE,CAyBrE;;;AACAsB,MAAAA,gBAAgB,CAACJ,KAAjB,CAAuB,MAAM,CAAE,CAA/B;AACArB,MAAAA,UAAU,CAACc,IAAX,CAAgBW,gBAAhB;AACD,KA5BD;;AA8BA,WAAOrC,OAAO,CACXC,GADI,CACAW,UAAU,CAAC2B,GAAX,CAAexD,SAAS,IAAIA,SAAS,CAACkD,KAAV,CAAgBO,SAAS,IAAI;AAC5D,YAAMC,SAAS,GAAG,CAAC,CAACD,SAAS,CAACE,aAA9B;;AACA,WAAKC,UAAL,CAAgBF,SAAhB,EAA2B1B,KAA3B,EAAkCyB,SAAlC,EAA6CvB,KAA7C,EAAoDuB,SAAS,CAACE,aAA9D,EAA6EF,SAAS,CAACI,aAAvF;AACD,KAHgC,CAA5B,CADA,CAAP;AAKD;AAED;;;;;;;;;;;;;;;AAaA,QAAMZ,sBAAN,CAA6BjD,SAA7B,EAAwC+C,aAAxC,EAAuDe,cAAvD,EAAuEC,QAAvE,EAAiFC,QAAjF,EAA2F;AACzF,QAAIC,OAAO,GAAG,KAAd;AAEA,UAAMC,cAAc,GAAGlE,SAAS,CAACqB,MAAjC,CAHyF,CAIzF;;AACA,QAAI8C,UAAU,GAAG,CAAjB;AACA,QAAIC,QAAQ,GAAGrB,aAAf;AACA,QAAIsB,UAAJ;;AACA,QAAIP,cAAJ,EAAoB;AAClBK,MAAAA,UAAU,GAAG,CAAb;AACAE,MAAAA,UAAU,GAAGN,QAAb;AACAK,MAAAA,QAAQ,GAAGJ,QAAX;AACD;;AACD,QAAIE,cAAc,KAAKC,UAAvB,EAAmC;AACjCF,MAAAA,OAAO,GAAG,IAAV;AACD;;AAED,QAAIA,OAAJ,EAAa;AACX,UAAI;AACF,YAAIH,cAAJ,EAAoB;AAClB,iBAAO,MAAM7D,SAAS,CAACD,SAAS,CAAC0B,IAAV,CAAe,KAAKtB,aAApB,EAAmCiE,UAAnC,CAAD,CAAT,EAAb;AACD;;AACD,eAAO,MAAMpE,SAAS,CAACD,SAAS,CAAC0B,IAAV,CAAe,KAAKtB,aAApB,CAAD,CAAT,EAAb;AACD,OALD,CAKE,OAAOkE,CAAP,EAAU;AACV,eAAO,KAAKV,UAAL,CAAgB,KAAhB,EAAuBQ,QAAvB,EAAiCE,CAAjC,EAAoCP,QAApC,EAA8ChB,aAA9C,CAAP;AACD;AACF;;AAED,QAAI;AACF,aAAO,MAAM/C,SAAS,CAAC0C,IAAV,CAAe,KAAKtC,aAApB,EAAmCiE,UAAnC,CAAb;AACD,KAFD,CAEE,OAAOC,CAAP,EAAU;AACV,aAAO,KAAKV,UAAL,CAAgB,KAAhB,EAAuBQ,QAAvB,EAAiCE,CAAjC,EAAoCP,QAApC,EAA8ChB,aAA9C,CAAP;AACD;AACF;AAED;;;;;;;;;;;;;;AAYA,QAAMQ,uBAAN,CAA8BrB,KAA9B,EAAqCkB,IAArC,EAA2CL,aAA3C,EAA0Df,KAA1D,EAAiE;AAC/D;AACA,UAAMuC,WAAW,GAAGC,MAAM,CAACtC,KAAD,CAA1B,CAF+D,CAG/D;;AACA,QAAI,OAAOlC,SAAS,CAAC+C,aAAD,CAAhB,KAAoC,UAAxC,EAAoD;AAClD,YAAM,IAAI/B,KAAJ,CAAW,+BAA8B+B,aAAc,EAAvD,CAAN;AACD;;AAED,UAAMc,aAAa,GAAG,KAAKY,qBAAL,CAA2BrB,IAA3B,EAAiCL,aAAjC,EAAgDf,KAAhD,CAAtB;;AAEA,QAAI,CAAChC,SAAS,CAAC+C,aAAD,CAAT,CAAyBwB,WAAzB,EAAsC,GAAGV,aAAzC,CAAL,EAA8D;AAC5D,YAAMnD,MAAM,CAACgE,MAAP,CAAc,IAAI1D,KAAJ,CAAUoC,IAAI,CAACC,GAAL,IAAa,cAAaN,aAAc,OAAMf,KAAM,SAA9D,CAAd,EAAuF;AAAE2B,QAAAA,aAAa,EAAEZ,aAAjB;AAAgCc,QAAAA;AAAhC,OAAvF,CAAN;AACD;AACF;AAED;;;;;;;;;;;AASAY,EAAAA,qBAAqB,CAACrB,IAAD,EAAOL,aAAP,EAAsBf,KAAtB,EAA6B;AAChD,QAAI6B,aAAa,GAAGT,IAAI,CAACuB,IAAL,IAAavB,IAAjC;AACA,UAAMwB,oBAAoB,GAAG,OAAOf,aAAP,KAAyB,QAAzB,KAAsCd,aAAa,KAAK,SAAlB,IAA+BA,aAAa,KAAK,gBAAjD,IAAqEA,aAAa,KAAK,eAA7H,CAA7B;;AAEA,QAAI,CAAC8B,KAAK,CAACC,OAAN,CAAcjB,aAAd,CAAL,EAAmC;AACjC,UAAId,aAAa,KAAK,aAAtB,EAAqC;AACnCc,QAAAA,aAAa,GAAG,CAACA,aAAD,EAAgB7B,KAAhB,EAAuB,KAAK5B,aAA5B,CAAhB;AACD,OAFD,MAEO,IAAIwE,oBAAoB,IAAI7B,aAAa,KAAK,MAA9C,EAAsD;AAC3Dc,QAAAA,aAAa,GAAG,EAAhB;AACD,OAFM,MAEA;AACLA,QAAAA,aAAa,GAAG,CAACA,aAAD,CAAhB;AACD;AACF,KARD,MAQO;AACLA,MAAAA,aAAa,GAAGA,aAAa,CAACkB,KAAd,CAAoB,CAApB,CAAhB;AACD;;AACD,WAAOlB,aAAP;AACD;AAED;;;;;;;;;;;AASAtB,EAAAA,eAAe,CAACR,YAAD,EAAeC,KAAf,EAAsBE,KAAtB,EAA6B;AAC1C,QAAIH,YAAY,CAACc,SAAb,KAA2B,KAA3B,KAAqCX,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKiB,SAAjE,CAAJ,EAAiF;AAC/E,YAAM6B,WAAW,GAAGtE,MAAM,CAACuE,MAAP,CAAc,KAAK7E,aAAL,CAAmBD,WAAnB,CAA+B+E,YAA7C,EAA2DC,IAA3D,CAAgEH,WAAW,IAAIA,WAAW,YAAYjF,SAAvB,IAAoCiF,WAAW,CAACI,UAAZ,KAA2BrD,YAAY,CAACsD,SAA3J,CAApB;;AACA,UAAI,CAACL,WAAD,IAAgB,CAAC,KAAK5E,aAAL,CAAmBkF,GAAnB,CAAuBN,WAAW,CAACO,mBAAnC,CAArB,EAA8E;AAC5E,cAAM1D,UAAU,GAAG,KAAKzB,aAAL,CAAmByB,UAAnB,CAA8BG,KAA9B,CAAnB;;AACA,cAAMwD,MAAM,GAAG9F,CAAC,CAAC4F,GAAF,CAAMzD,UAAN,EAAkB,aAAlB,EAAkC,GAAE,KAAKzB,aAAL,CAAmBD,WAAnB,CAA+BsF,IAAK,IAAGzD,KAAM,iBAAjF,CAAf;;AAEA,aAAKnB,MAAL,CAAY8B,IAAZ,CAAiB,IAAI9C,cAAc,CAAC6F,mBAAnB,CACfF,MADe,EAEf,mBAFe,EAEM;AACrBxD,QAAAA,KAHe,EAIfE,KAJe,EAKf,KAAK9B,aALU,EAMf,SANe,CAAjB;AAQD;AACF;;AAED,QAAI2B,YAAY,CAAC4D,IAAb,YAA6B7F,SAAS,CAAC8F,MAAvC,IAAiD7D,YAAY,CAAC4D,IAAb,YAA6B7F,SAAS,CAAC+F,IAAxF,IAAgG9D,YAAY,CAAC4D,IAAb,YAA6B7F,SAAS,CAACgG,MAA3I,EAAmJ;AACjJ,UAAIjB,KAAK,CAACC,OAAN,CAAc5C,KAAd,KAAwBxC,CAAC,CAACqG,QAAF,CAAW7D,KAAX,KAAqB,EAAEA,KAAK,YAAYtC,KAAK,CAACwC,eAAzB,CAArB,IAAkE,CAAC4D,MAAM,CAACC,QAAP,CAAgB/D,KAAhB,CAA/F,EAAuH;AACrH,aAAKrB,MAAL,CAAY8B,IAAZ,CAAiB,IAAI9C,cAAc,CAAC6F,mBAAnB,CACd,GAAE1D,KAAM,kCADM,EAEf,kBAFe,EAEK;AACpBA,QAAAA,KAHe,EAIfE,KAJe,EAKf,KAAK9B,aALU,EAMf,cANe,CAAjB;AAQD;AACF;AACF;AAED;;;;;;;;;;;;;;AAYAwD,EAAAA,UAAU,CAACsC,SAAD,EAAY9B,QAAZ,EAAsB+B,QAAtB,EAAgCjE,KAAhC,EAAuCkE,MAAvC,EAA+CC,MAA/C,EAAuD;AAC/D,UAAMC,OAAO,GAAGH,QAAQ,CAACG,OAAT,IAAoBH,QAApB,IAAgC,kBAAhD;AACA,UAAMxE,KAAK,GAAG,IAAI9B,cAAc,CAAC6F,mBAAnB,CACZY,OADY,EAEZ,kBAFY,EAEQ;AACpBlC,IAAAA,QAHY,EAIZlC,KAJY,EAKZ,KAAK9B,aALO,EAMZgG,MANY,EAOZF,SAAS,GAAGE,MAAH,GAAYjD,SAPT,EAQZ+C,SAAS,GAAGG,MAAH,GAAYlD,SART,CAAd;AAWAxB,IAAAA,KAAK,CAACzB,iBAAiB,CAACqG,YAAnB,CAAL,GAAwCJ,QAAxC;AAEA,SAAKtF,MAAL,CAAY8B,IAAZ,CAAiBhB,KAAjB;AACD;;AAnYqB;AAqYxB;;;;;;;;AAMAzB,iBAAiB,CAACqG,YAAlB,GAAiC,UAAjC;AAEAC,MAAM,CAACC,OAAP,GAAiBvG,iBAAjB;AACAsG,MAAM,CAACC,OAAP,CAAevG,iBAAf,GAAmCA,iBAAnC;AACAsG,MAAM,CAACC,OAAP,CAAeC,OAAf,GAAyBxG,iBAAzB","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('./utils');\nconst sequelizeError = require('./errors');\nconst DataTypes = require('./data-types');\nconst BelongsTo = require('./associations/belongs-to');\nconst validator = require('./utils/validator-extras').validator;\nconst { promisify } = require('util');\n\n/**\n * Instance Validator.\n *\n * @param {Instance} modelInstance The model instance.\n * @param {object} options A dictionary with options.\n *\n * @private\n */\nclass InstanceValidator {\n  constructor(modelInstance, options) {\n    options = {\n      // assign defined and default options\n      hooks: true,\n      ...options\n    };\n\n    if (options.fields && !options.skip) {\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    } else {\n      options.skip = options.skip || [];\n    }\n\n    this.options = options;\n\n    this.modelInstance = modelInstance;\n\n    /**\n     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`\n     *\n     * @name validator\n     * @private\n     */\n    this.validator = validator;\n\n    /**\n     *  All errors will be stored here from the validations.\n     *\n     * @type {Array} Will contain keys that correspond to attributes which will\n     *   be Arrays of Errors.\n     * @private\n     */\n    this.errors = [];\n\n    /**\n     * @type {boolean} Indicates if validations are in progress\n     * @private\n     */\n    this.inProgress = false;\n  }\n\n  /**\n   * The main entry point for the Validation module, invoke to start the dance.\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async _validate() {\n    if (this.inProgress) throw new Error('Validations already in progress.');\n\n    this.inProgress = true;\n\n    await Promise.all([\n      this._perAttributeValidators(),\n      this._customValidators()\n    ]);\n\n    if (this.errors.length) {\n      throw new sequelizeError.ValidationError(null, this.errors);\n    }\n  }\n\n  /**\n   * Invoke the Validation sequence and run validation hooks if defined\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async validate() {\n    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());\n  }\n\n  /**\n   * Invoke the Validation sequence and run hooks\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async _validateAndRunHooks() {\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    await runHooks('beforeValidate', this.modelInstance, this.options);\n\n    try {\n      await this._validate();\n    } catch (error) {\n      const newError = await runHooks('validationFailed', this.modelInstance, this.options, error);\n      throw newError || error;\n    }\n\n    await runHooks('afterValidate', this.modelInstance, this.options);\n    return this.modelInstance;\n  }\n\n  /**\n   * Will run all the validators defined per attribute (built-in validators and custom validators)\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async _perAttributeValidators() {\n    // promisify all attribute invocations\n    const validators = [];\n\n    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\n      if (this.options.skip.includes(field)) {\n        return;\n      }\n\n      const value = this.modelInstance.dataValues[field];\n\n      if (value instanceof Utils.SequelizeMethod) {\n        return;\n      }\n\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n        // perform validations based on schema\n        this._validateSchema(rawAttribute, field, value);\n      }\n\n      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {\n        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));\n      }\n    });\n\n    return await Promise.all(validators);\n  }\n\n  /**\n   * Will run all the custom validators defined in the model's options.\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async _customValidators() {\n    const validators = [];\n    _.each(this.modelInstance.constructor.options.validate, (validator, validatorType) => {\n      if (this.options.skip.includes(validatorType)) {\n        return;\n      }\n\n      const valprom = this._invokeCustomValidator(validator, validatorType)\n        // errors are handled in settling, stub this\n        .catch(() => {});\n\n      validators.push(valprom);\n    });\n\n    return await Promise.all(validators);\n  }\n\n  /**\n   * Validate a single attribute with all the defined built-in validators and custom validators.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {string} field The field name.\n   * @param {boolean} allowNull Whether or not the schema allows null values\n   *\n   * @returns {Promise} A promise, will always resolve, auto populates error on this.error local object.\n   */\n  async _singleAttrValidate(value, field, allowNull) {\n    // If value is null and allowNull is false, no validators should run (see #9143)\n    if ((value === null || value === undefined) && !allowNull) {\n      // The schema validator (_validateSchema) has already generated the validation error. Nothing to do here.\n      return;\n    }\n\n    // Promisify each validator\n    const validators = [];\n    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {\n\n      if (validatorType === 'isUrl' || validatorType === 'isURL' || validatorType === 'isEmail') {\n        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object\n        if (typeof test === 'object' && test !== null && test.msg) {\n          test = {\n            msg: test.msg\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      }\n\n      // Custom validators should always run, except if value is null and allowNull is false (see #9143)\n      if (typeof test === 'function') {\n        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));\n        return;\n      }\n\n      // If value is null, built-in validators should not run (only custom validators have to run) (see #9134).\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);\n      // errors are handled in settling, stub this\n      validatorPromise.catch(() => {});\n      validators.push(validatorPromise);\n    });\n\n    return Promise\n      .all(validators.map(validator => validator.catch(rejection => {\n        const isBuiltIn = !!rejection.validatorName;\n        this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);\n      })));\n  }\n\n  /**\n   * Prepare and invoke a custom validator.\n   *\n   * @private\n   *\n   * @param {Function} validator The custom validator.\n   * @param {string} validatorType the custom validator type (name).\n   * @param {boolean} optAttrDefined Set to true if custom validator was defined from the attribute\n   * @param {*} optValue value for attribute\n   * @param {string} optField field for attribute\n   *\n   * @returns {Promise} A promise.\n   */\n  async _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {\n    let isAsync = false;\n\n    const validatorArity = validator.length;\n    // check if validator is async and requires a callback\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n\n    if (isAsync) {\n      try {\n        if (optAttrDefined) {\n          return await promisify(validator.bind(this.modelInstance, invokeArgs))();\n        }\n        return await promisify(validator.bind(this.modelInstance))();\n      } catch (e) {\n        return this._pushError(false, errorKey, e, optValue, validatorType);\n      }\n    }\n\n    try {\n      return await validator.call(this.modelInstance, invokeArgs);\n    } catch (e) {\n      return this._pushError(false, errorKey, e, optValue, validatorType);\n    }\n  }\n\n  /**\n   * Prepare and invoke a build-in validator.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated\n   *\n   * @returns {object} An object with specific keys to invoke the validator.\n   */\n  async _invokeBuiltinValidator(value, test, validatorType, field) {\n    // Cast value as string to pass new Validator.js string requirement\n    const valueString = String(value);\n    // check if Validator knows that kind of validation test\n    if (typeof validator[validatorType] !== 'function') {\n      throw new Error(`Invalid validator function: ${validatorType}`);\n    }\n\n    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n\n    if (!validator[validatorType](valueString, ...validatorArgs)) {\n      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), { validatorName: validatorType, validatorArgs });\n    }\n  }\n\n  /**\n   * Will extract arguments for the validator.\n   *\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated.\n   *\n   * @private\n   */\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator = typeof validatorArgs !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');\n\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === 'isImmutable') {\n        validatorArgs = [validatorArgs, field, this.modelInstance];\n      } else if (isLocalizedValidator || validatorType === 'isIP') {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = validatorArgs.slice(0);\n    }\n    return validatorArgs;\n  }\n\n  /**\n   * Will validate a single field against its schema definition (isnull).\n   *\n   * @param {object} rawAttribute As defined in the Schema.\n   * @param {string} field The field name.\n   * @param {*} value anything.\n   *\n   * @private\n   */\n  _validateSchema(rawAttribute, field, value) {\n    if (rawAttribute.allowNull === false && (value === null || value === undefined)) {\n      const association = Object.values(this.modelInstance.constructor.associations).find(association => association instanceof BelongsTo && association.foreignKey === rawAttribute.fieldName);\n      if (!association || !this.modelInstance.get(association.associationAccessor)) {\n        const validators = this.modelInstance.validators[field];\n        const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);\n\n        this.errors.push(new sequelizeError.ValidationErrorItem(\n          errMsg,\n          'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n          field,\n          value,\n          this.modelInstance,\n          'is_null'\n        ));\n      }\n    }\n\n    if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {\n      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n        this.errors.push(new sequelizeError.ValidationErrorItem(\n          `${field} cannot be an array or an object`,\n          'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n          field,\n          value,\n          this.modelInstance,\n          'not_a_string'\n        ));\n      }\n    }\n  }\n\n  /**\n   * Signs all errors retaining the original.\n   *\n   * @param {boolean}       isBuiltin   - Determines if error is from builtin validator.\n   * @param {string}        errorKey    - name of invalid attribute.\n   * @param {Error|string}  rawError    - The original error.\n   * @param {string|number} value       - The data that triggered the error.\n   * @param {string}        fnName      - Name of the validator, if any\n   * @param {Array}         fnArgs      - Arguments for the validator [function], if any\n   *\n   * @private\n   */\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n    const message = rawError.message || rawError || 'Validation error';\n    const error = new sequelizeError.ValidationErrorItem(\n      message,\n      'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,\n      errorKey,\n      value,\n      this.modelInstance,\n      fnName,\n      isBuiltin ? fnName : undefined,\n      isBuiltin ? fnArgs : undefined\n    );\n\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n\n    this.errors.push(error);\n  }\n}\n/**\n * The error key for arguments as passed by custom validators\n *\n * @type {string}\n * @private\n */\nInstanceValidator.RAW_KEY_NAME = 'original';\n\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports.default = InstanceValidator;\n"]},"metadata":{},"sourceType":"script"}