{"ast":null,"code":"'use strict';\n\nconst DataTypes = require('../../data-types');\n\nconst QueryTypes = require('../../query-types');\n\nconst {\n  QueryInterface\n} = require('../abstract/query-interface');\n\nconst Utils = require('../../utils');\n/**\n * The interface that Sequelize uses to talk with Postgres database\n */\n\n\nclass PostgresQueryInterface extends QueryInterface {\n  /**\n   * Ensure enum and their values.\n   *\n   * @param {string} tableName  Name of table to create\n   * @param {object} attributes Object representing a list of normalized table attributes\n   * @param {object} [options]\n   * @param {Model}  [model]\n   *\n   * @protected\n   */\n  async ensureEnums(tableName, attributes, options, model) {\n    const keys = Object.keys(attributes);\n    const keyLen = keys.length;\n    let sql = '';\n    let promises = [];\n    let i = 0;\n\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n\n      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n      ) {\n          sql = this.queryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n          promises.push(this.sequelize.query(sql, { ...options,\n            plain: true,\n            raw: true,\n            type: QueryTypes.SELECT\n          }));\n        }\n    }\n\n    const results = await Promise.all(promises);\n    promises = [];\n    let enumIdx = 0; // This little function allows us to re-use the same code that prepends or appends new value to enum array\n\n    const addEnumValue = (field, value, relativeValue, position = 'before', spliceStart = promises.length) => {\n      const valueOptions = { ...options\n      };\n      valueOptions.before = null;\n      valueOptions.after = null;\n\n      switch (position) {\n        case 'after':\n          valueOptions.after = relativeValue;\n          break;\n\n        case 'before':\n        default:\n          valueOptions.before = relativeValue;\n          break;\n      }\n\n      promises.splice(spliceStart, 0, () => {\n        return this.sequelize.query(this.queryGenerator.pgEnumAdd(tableName, field, value, valueOptions), valueOptions);\n      });\n    };\n\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n      const enumType = type.type || type;\n      const field = attribute.field || keys[i];\n\n      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n      ) {\n          // If the enum type doesn't exist then create it\n          if (!results[enumIdx]) {\n            promises.push(() => {\n              return this.sequelize.query(this.queryGenerator.pgEnum(tableName, field, enumType, options), { ...options,\n                raw: true\n              });\n            });\n          } else if (!!results[enumIdx] && !!model) {\n            const enumVals = this.queryGenerator.fromArray(results[enumIdx].enum_value);\n            const vals = enumType.values; // Going through already existing values allows us to make queries that depend on those values\n            // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values\n            // Then we append the rest of new values AFTER the latest already existing value\n            // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]\n            // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]\n            // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]\n\n            let lastOldEnumValue;\n            let rightestPosition = -1;\n\n            for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n              const enumVal = enumVals[oldIndex];\n              const newIdx = vals.indexOf(enumVal);\n              lastOldEnumValue = enumVal;\n\n              if (newIdx === -1) {\n                continue;\n              }\n\n              const newValuesBefore = vals.slice(0, newIdx);\n              const promisesLength = promises.length; // we go in reverse order so we could stop when we meet old value\n\n              for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n                if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n                  break;\n                }\n\n                addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);\n              } // we detect the most 'right' position of old value in new enum array so we can append new values to it\n\n\n              if (newIdx > rightestPosition) {\n                rightestPosition = newIdx;\n              }\n            }\n\n            if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n              const remainingEnumValues = vals.slice(rightestPosition + 1);\n\n              for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n                addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');\n              }\n            }\n\n            enumIdx++;\n          }\n        }\n    }\n\n    const result = await promises.reduce(async (promise, asyncFunction) => await asyncFunction(await promise), Promise.resolve()); // If ENUM processed, then refresh OIDs\n\n    if (promises.length) {\n      await this.sequelize.dialect.connectionManager._refreshDynamicOIDs();\n    }\n\n    return result;\n  }\n  /**\n   * @override\n   */\n\n\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = { ...options,\n      type: QueryTypes.FOREIGNKEYS\n    }; // postgres needs some special treatment as those field names returned are all lowercase\n    // in order to keep same result with other dialects.\n\n    const query = this.queryGenerator.getForeignKeyReferencesQuery(tableName, this.sequelize.config.database);\n    const result = await this.sequelize.query(query, queryOptions);\n    return result.map(Utils.camelizeObjectKeys);\n  }\n  /**\n   * Drop specified enum from database (Postgres only)\n   *\n   * @param {string} [enumName]  Enum name to drop\n   * @param {object} options Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  async dropEnum(enumName, options) {\n    options = options || {};\n    return this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(enumName)), { ...options,\n      raw: true\n    });\n  }\n  /**\n   * Drop all enums from database (Postgres only)\n   *\n   * @param {object} options Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  async dropAllEnums(options) {\n    options = options || {};\n    const enums = await this.pgListEnums(null, options);\n    return await Promise.all(enums.map(result => this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(result.enum_name)), { ...options,\n      raw: true\n    })));\n  }\n  /**\n   * List all enums (Postgres only)\n   *\n   * @param {string} [tableName]  Table whose enum to list\n   * @param {object} [options]    Query options\n   *\n   * @returns {Promise}\n   */\n\n\n  async pgListEnums(tableName, options) {\n    options = options || {};\n    const sql = this.queryGenerator.pgListEnums(tableName);\n    return this.sequelize.query(sql, { ...options,\n      plain: false,\n      raw: true,\n      type: QueryTypes.SELECT\n    });\n  }\n  /**\n   * Since postgres has a special case for enums, we should drop the related\n   * enum type within the table and attribute\n   *\n   * @override\n   */\n\n\n  async dropTable(tableName, options) {\n    await super.dropTable(tableName, options);\n    const promises = [];\n    const instanceTable = this.sequelize.modelManager.getModel(tableName, {\n      attribute: 'tableName'\n    });\n\n    if (!instanceTable) {\n      // Do nothing when model is not available\n      return;\n    }\n\n    const getTableName = (!options || !options.schema || options.schema === 'public' ? '' : `${options.schema}_`) + tableName;\n    const keys = Object.keys(instanceTable.rawAttributes);\n    const keyLen = keys.length;\n\n    for (let i = 0; i < keyLen; i++) {\n      if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n        const sql = this.queryGenerator.pgEnumDrop(getTableName, keys[i]);\n        options.supportsSearchPath = false;\n        promises.push(this.sequelize.query(sql, { ...options,\n          raw: true\n        }));\n      }\n    }\n\n    await Promise.all(promises);\n  }\n\n}\n\nexports.PostgresQueryInterface = PostgresQueryInterface;","map":{"version":3,"sources":["/home/nawan44/Documents/github/portofolio/CRUD/node_modules/sequelize/lib/dialects/postgres/query-interface.js"],"names":["DataTypes","require","QueryTypes","QueryInterface","Utils","PostgresQueryInterface","ensureEnums","tableName","attributes","options","model","keys","Object","keyLen","length","sql","promises","i","attribute","type","ENUM","ARRAY","queryGenerator","pgListEnums","field","push","sequelize","query","plain","raw","SELECT","results","Promise","all","enumIdx","addEnumValue","value","relativeValue","position","spliceStart","valueOptions","before","after","splice","pgEnumAdd","enumType","pgEnum","enumVals","fromArray","enum_value","vals","values","lastOldEnumValue","rightestPosition","oldIndex","enumVal","newIdx","indexOf","newValuesBefore","slice","promisesLength","reverseIdx","remainingEnumValues","result","reduce","promise","asyncFunction","resolve","dialect","connectionManager","_refreshDynamicOIDs","getForeignKeyReferencesForTable","queryOptions","FOREIGNKEYS","getForeignKeyReferencesQuery","config","database","map","camelizeObjectKeys","dropEnum","enumName","pgEnumDrop","pgEscapeAndQuote","dropAllEnums","enums","enum_name","dropTable","instanceTable","modelManager","getModel","getTableName","schema","rawAttributes","supportsSearchPath","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst DataTypes = require('../../data-types');\nconst QueryTypes = require('../../query-types');\nconst { QueryInterface } = require('../abstract/query-interface');\nconst Utils = require('../../utils');\n\n/**\n * The interface that Sequelize uses to talk with Postgres database\n */\nclass PostgresQueryInterface extends QueryInterface {\n  /**\n   * Ensure enum and their values.\n   *\n   * @param {string} tableName  Name of table to create\n   * @param {object} attributes Object representing a list of normalized table attributes\n   * @param {object} [options]\n   * @param {Model}  [model]\n   *\n   * @protected\n   */\n  async ensureEnums(tableName, attributes, options, model) {\n    const keys = Object.keys(attributes);\n    const keyLen = keys.length;\n\n    let sql = '';\n    let promises = [];\n    let i = 0;\n\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n\n      if (\n        type instanceof DataTypes.ENUM ||\n        type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n      ) {\n        sql = this.queryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n        promises.push(this.sequelize.query(\n          sql,\n          { ...options, plain: true, raw: true, type: QueryTypes.SELECT }\n        ));\n      }\n    }\n\n    const results = await Promise.all(promises);\n    promises = [];\n    let enumIdx = 0;\n\n    // This little function allows us to re-use the same code that prepends or appends new value to enum array\n    const addEnumValue = (field, value, relativeValue, position = 'before', spliceStart = promises.length) => {\n      const valueOptions = { ...options };\n      valueOptions.before = null;\n      valueOptions.after = null;\n\n      switch (position) {\n        case 'after':\n          valueOptions.after = relativeValue;\n          break;\n        case 'before':\n        default:\n          valueOptions.before = relativeValue;\n          break;\n      }\n\n      promises.splice(spliceStart, 0, () => {\n        return this.sequelize.query(this.queryGenerator.pgEnumAdd(\n          tableName, field, value, valueOptions\n        ), valueOptions);\n      });\n    };\n\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n      const enumType = type.type || type;\n      const field = attribute.field || keys[i];\n\n      if (\n        type instanceof DataTypes.ENUM ||\n        type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n      ) {\n        // If the enum type doesn't exist then create it\n        if (!results[enumIdx]) {\n          promises.push(() => {\n            return this.sequelize.query(this.queryGenerator.pgEnum(tableName, field, enumType, options), { ...options, raw: true });\n          });\n        } else if (!!results[enumIdx] && !!model) {\n          const enumVals = this.queryGenerator.fromArray(results[enumIdx].enum_value);\n          const vals = enumType.values;\n\n          // Going through already existing values allows us to make queries that depend on those values\n          // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values\n          // Then we append the rest of new values AFTER the latest already existing value\n          // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]\n          // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]\n          // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]\n          let lastOldEnumValue;\n          let rightestPosition = -1;\n          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n            const enumVal = enumVals[oldIndex];\n            const newIdx = vals.indexOf(enumVal);\n            lastOldEnumValue = enumVal;\n\n            if (newIdx === -1) {\n              continue;\n            }\n\n            const newValuesBefore = vals.slice(0, newIdx);\n            const promisesLength = promises.length;\n            // we go in reverse order so we could stop when we meet old value\n            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n                break;\n              }\n\n              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);\n            }\n\n            // we detect the most 'right' position of old value in new enum array so we can append new values to it\n            if (newIdx > rightestPosition) {\n              rightestPosition = newIdx;\n            }\n          }\n\n          if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n            const remainingEnumValues = vals.slice(rightestPosition + 1);\n            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');\n            }\n          }\n\n          enumIdx++;\n        }\n      }\n    }\n\n    const result = await promises\n      .reduce(async (promise, asyncFunction) => await asyncFunction(await promise), Promise.resolve());\n\n    // If ENUM processed, then refresh OIDs\n    if (promises.length) {\n      await this.sequelize.dialect.connectionManager._refreshDynamicOIDs();\n    }\n    return result;\n  }\n\n  /**\n   * @override\n   */\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = {\n      ...options,\n      type: QueryTypes.FOREIGNKEYS\n    };\n\n    // postgres needs some special treatment as those field names returned are all lowercase\n    // in order to keep same result with other dialects.\n    const query = this.queryGenerator.getForeignKeyReferencesQuery(tableName, this.sequelize.config.database);\n    const result = await this.sequelize.query(query, queryOptions);\n    return result.map(Utils.camelizeObjectKeys);\n  }\n\n  /**\n   * Drop specified enum from database (Postgres only)\n   *\n   * @param {string} [enumName]  Enum name to drop\n   * @param {object} options Query options\n   *\n   * @returns {Promise}\n   */\n  async dropEnum(enumName, options) {\n    options = options || {};\n\n    return this.sequelize.query(\n      this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(enumName)),\n      { ...options, raw: true }\n    );\n  }\n\n  /**\n   * Drop all enums from database (Postgres only)\n   *\n   * @param {object} options Query options\n   *\n   * @returns {Promise}\n   */\n  async dropAllEnums(options) {\n    options = options || {};\n\n    const enums = await this.pgListEnums(null, options);\n\n    return await Promise.all(enums.map(result => this.sequelize.query(\n      this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(result.enum_name)),\n      { ...options, raw: true }\n    )));\n  }\n\n  /**\n   * List all enums (Postgres only)\n   *\n   * @param {string} [tableName]  Table whose enum to list\n   * @param {object} [options]    Query options\n   *\n   * @returns {Promise}\n   */\n  async pgListEnums(tableName, options) {\n    options = options || {};\n    const sql = this.queryGenerator.pgListEnums(tableName);\n    return this.sequelize.query(sql, { ...options, plain: false, raw: true, type: QueryTypes.SELECT });\n  }\n\n  /**\n   * Since postgres has a special case for enums, we should drop the related\n   * enum type within the table and attribute\n   *\n   * @override\n   */\n  async dropTable(tableName, options) {\n    await super.dropTable(tableName, options);\n    const promises = [];\n    const instanceTable = this.sequelize.modelManager.getModel(tableName, { attribute: 'tableName' });\n\n    if (!instanceTable) {\n      // Do nothing when model is not available\n      return;\n    }\n\n    const getTableName = (!options || !options.schema || options.schema === 'public' ? '' : `${options.schema}_`) + tableName;\n\n    const keys = Object.keys(instanceTable.rawAttributes);\n    const keyLen = keys.length;\n\n    for (let i = 0; i < keyLen; i++) {\n      if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n        const sql = this.queryGenerator.pgEnumDrop(getTableName, keys[i]);\n        options.supportsSearchPath = false;\n        promises.push(this.sequelize.query(sql, { ...options, raw: true }));\n      }\n    }\n\n    await Promise.all(promises);\n  }\n}\n\nexports.PostgresQueryInterface = PostgresQueryInterface;\n"]},"metadata":{},"sourceType":"script"}