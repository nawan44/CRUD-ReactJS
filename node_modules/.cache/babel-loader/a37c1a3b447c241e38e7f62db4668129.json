{"ast":null,"code":"'use strict';\n\nconst semver = require('semver');\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\n\nconst SequelizeErrors = require('../../errors');\n\nconst {\n  logger\n} = require('../../utils/logger');\n\nconst DataTypes = require('../../data-types').mariadb;\n\nconst momentTz = require('moment-timezone');\n\nconst debug = logger.debugContext('connection:mariadb');\n\nconst parserStore = require('../parserStore')('mariadb');\n/**\n * MariaDB Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle MariaDB specific connections\n * Use https://github.com/MariaDB/mariadb-connector-nodejs to connect with MariaDB server\n *\n * @private\n */\n\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('mariadb');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n\n    return next();\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  /**\n   * Connect with MariaDB database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n\n\n  async connect(config) {\n    // Named timezone is not supported in mariadb, convert to offset\n    let tzOffset = this.sequelize.options.timezone;\n    tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;\n    const connectionConfig = {\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      password: config.password,\n      database: config.database,\n      timezone: tzOffset,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true,\n      foundRows: false,\n      ...config.dialectOptions\n    };\n\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      // set timezone for this connection\n      if (connectionConfig.initSql) {\n        if (!Array.isArray(connectionConfig.initSql)) {\n          connectionConfig.initSql = [connectionConfig.initSql];\n        }\n\n        connectionConfig.initSql.push(`SET time_zone = '${tzOffset}'`);\n      } else {\n        connectionConfig.initSql = `SET time_zone = '${tzOffset}'`;\n      }\n    }\n\n    try {\n      const connection = await this.lib.createConnection(connectionConfig);\n      this.sequelize.options.databaseVersion = semver.coerce(connection.serverVersion()).version;\n      debug('connection acquired');\n      connection.on('error', error => {\n        switch (error.code) {\n          case 'ESOCKET':\n          case 'ECONNRESET':\n          case 'EPIPE':\n          case 'PROTOCOL_CONNECTION_LOST':\n            this.pool.destroy(connection);\n        }\n      });\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case 'ECONNREFUSED':\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n\n        case 'ER_ACCESS_DENIED_ERROR':\n        case 'ER_ACCESS_DENIED_NO_PASSWORD_ERROR':\n          throw new SequelizeErrors.AccessDeniedError(err);\n\n        case 'ENOTFOUND':\n          throw new SequelizeErrors.HostNotFoundError(err);\n\n        case 'EHOSTUNREACH':\n        case 'ENETUNREACH':\n        case 'EADDRNOTAVAIL':\n          throw new SequelizeErrors.HostNotReachableError(err);\n\n        case 'EINVAL':\n          throw new SequelizeErrors.InvalidConnectionError(err);\n\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    // Don't disconnect connections with CLOSED state\n    if (!connection.isValid()) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return;\n    }\n\n    return await connection.end();\n  }\n\n  validate(connection) {\n    return connection && connection.isValid();\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"sources":["/home/nawan44/Documents/github/portofolio/CRUD/node_modules/sequelize/lib/dialects/mariadb/connection-manager.js"],"names":["semver","require","AbstractConnectionManager","SequelizeErrors","logger","DataTypes","mariadb","momentTz","debug","debugContext","parserStore","ConnectionManager","constructor","dialect","sequelize","config","port","lib","_loadDialectModule","refreshTypeParser","_typecast","field","next","get","type","options","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","connect","tzOffset","timezone","test","tz","format","connectionConfig","host","user","username","password","database","typeCast","bind","bigNumberStrings","supportBigNumbers","foundRows","dialectOptions","keepDefaultTimezone","initSql","Array","isArray","push","connection","createConnection","databaseVersion","coerce","serverVersion","version","on","error","code","pool","destroy","err","ConnectionRefusedError","AccessDeniedError","HostNotFoundError","HostNotReachableError","InvalidConnectionError","ConnectionError","disconnect","isValid","end","validate","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst semver = require('semver');\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst SequelizeErrors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst DataTypes = require('../../data-types').mariadb;\nconst momentTz = require('moment-timezone');\nconst debug = logger.debugContext('connection:mariadb');\nconst parserStore = require('../parserStore')('mariadb');\n\n/**\n * MariaDB Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle MariaDB specific connections\n * Use https://github.com/MariaDB/mariadb-connector-nodejs to connect with MariaDB server\n *\n * @private\n */\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('mariadb');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  /**\n   * Connect with MariaDB database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  async connect(config) {\n    // Named timezone is not supported in mariadb, convert to offset\n    let tzOffset = this.sequelize.options.timezone;\n    tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z')\n      : tzOffset;\n\n    const connectionConfig = {\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      password: config.password,\n      database: config.database,\n      timezone: tzOffset,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true,\n      foundRows: false,\n      ...config.dialectOptions\n    };\n\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      // set timezone for this connection\n      if (connectionConfig.initSql) {\n        if (!Array.isArray(\n          connectionConfig.initSql)) {\n          connectionConfig.initSql = [connectionConfig.initSql];\n        }\n        connectionConfig.initSql.push(`SET time_zone = '${tzOffset}'`);\n      } else {\n        connectionConfig.initSql = `SET time_zone = '${tzOffset}'`;\n      }\n    }\n\n    try {\n      const connection = await this.lib.createConnection(connectionConfig);\n      this.sequelize.options.databaseVersion = semver.coerce(connection.serverVersion()).version;\n\n      debug('connection acquired');\n      connection.on('error', error => {\n        switch (error.code) {\n          case 'ESOCKET':\n          case 'ECONNRESET':\n          case 'EPIPE':\n          case 'PROTOCOL_CONNECTION_LOST':\n            this.pool.destroy(connection);\n        }\n      });\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case 'ECONNREFUSED':\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case 'ER_ACCESS_DENIED_ERROR':\n        case 'ER_ACCESS_DENIED_NO_PASSWORD_ERROR':\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case 'ENOTFOUND':\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case 'EHOSTUNREACH':\n        case 'ENETUNREACH':\n        case 'EADDRNOTAVAIL':\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case 'EINVAL':\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    // Don't disconnect connections with CLOSED state\n    if (!connection.isValid()) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return;\n    }\n    return await connection.end();\n  }\n\n  validate(connection) {\n    return connection && connection.isValid();\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}