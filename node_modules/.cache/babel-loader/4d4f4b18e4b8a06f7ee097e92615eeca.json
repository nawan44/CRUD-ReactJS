{"ast":null,"code":"'use strict';\n\nconst BaseError = require('../../errors/base-error');\n\nconst ConnectionError = require('../../errors/connection-error');\n/**\n * Thrown when a connection to a database is closed while an operation is in progress\n */\n\n\nclass AsyncQueueError extends BaseError {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeAsyncQueueError';\n  }\n\n}\n\nexports.AsyncQueueError = AsyncQueueError;\n\nclass AsyncQueue {\n  constructor() {\n    this.previous = Promise.resolve();\n    this.closed = false;\n\n    this.rejectCurrent = () => {};\n  }\n\n  close() {\n    this.closed = true;\n    this.rejectCurrent(new ConnectionError(new AsyncQueueError('the connection was closed before this query could finish executing')));\n  }\n\n  enqueue(asyncFunction) {\n    // This outer promise might seems superflous since down below we return asyncFunction().then(resolve, reject).\n    // However, this ensures that this.previous will never be a rejected promise so the queue will\n    // always keep going, while still communicating rejection from asyncFunction to the user.\n    return new Promise((resolve, reject) => {\n      this.previous = this.previous.then(() => {\n        this.rejectCurrent = reject;\n\n        if (this.closed) {\n          return reject(new ConnectionError(new AsyncQueueError('the connection was closed before this query could be executed')));\n        }\n\n        return asyncFunction().then(resolve, reject);\n      });\n    });\n  }\n\n}\n\nexports.default = AsyncQueue;","map":{"version":3,"sources":["/home/nawan44/Documents/github/portofolio/CRUD/node_modules/sequelize/lib/dialects/mssql/async-queue.js"],"names":["BaseError","require","ConnectionError","AsyncQueueError","constructor","message","name","exports","AsyncQueue","previous","Promise","resolve","closed","rejectCurrent","close","enqueue","asyncFunction","reject","then","default"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,yBAAD,CAAzB;;AACA,MAAMC,eAAe,GAAGD,OAAO,CAAC,+BAAD,CAA/B;AAEA;;;;;AAGA,MAAME,eAAN,SAA8BH,SAA9B,CAAwC;AACtCI,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,UAAMA,OAAN;AACA,SAAKC,IAAL,GAAY,0BAAZ;AACD;;AAJqC;;AAOxCC,OAAO,CAACJ,eAAR,GAA0BA,eAA1B;;AAEA,MAAMK,UAAN,CAAiB;AACfJ,EAAAA,WAAW,GAAG;AACZ,SAAKK,QAAL,GAAgBC,OAAO,CAACC,OAAR,EAAhB;AACA,SAAKC,MAAL,GAAc,KAAd;;AACA,SAAKC,aAAL,GAAqB,MAAM,CAAE,CAA7B;AACD;;AACDC,EAAAA,KAAK,GAAG;AACN,SAAKF,MAAL,GAAc,IAAd;AACA,SAAKC,aAAL,CAAmB,IAAIX,eAAJ,CAAoB,IAAIC,eAAJ,CAAoB,oEAApB,CAApB,CAAnB;AACD;;AACDY,EAAAA,OAAO,CAACC,aAAD,EAAgB;AACrB;AACA;AACA;AACA,WAAO,IAAIN,OAAJ,CAAY,CAACC,OAAD,EAAUM,MAAV,KAAqB;AACtC,WAAKR,QAAL,GAAgB,KAAKA,QAAL,CAAcS,IAAd,CACd,MAAM;AACJ,aAAKL,aAAL,GAAqBI,MAArB;;AACA,YAAI,KAAKL,MAAT,EAAiB;AACf,iBAAOK,MAAM,CAAC,IAAIf,eAAJ,CAAoB,IAAIC,eAAJ,CAAoB,+DAApB,CAApB,CAAD,CAAb;AACD;;AACD,eAAOa,aAAa,GAAGE,IAAhB,CAAqBP,OAArB,EAA8BM,MAA9B,CAAP;AACD,OAPa,CAAhB;AASD,KAVM,CAAP;AAWD;;AAzBc;;AA4BjBV,OAAO,CAACY,OAAR,GAAkBX,UAAlB","sourcesContent":["'use strict';\n\nconst BaseError = require('../../errors/base-error');\nconst ConnectionError = require('../../errors/connection-error');\n\n/**\n * Thrown when a connection to a database is closed while an operation is in progress\n */\nclass AsyncQueueError extends BaseError {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeAsyncQueueError';\n  }\n}\n\nexports.AsyncQueueError = AsyncQueueError;\n\nclass AsyncQueue {\n  constructor() {\n    this.previous = Promise.resolve();\n    this.closed = false;\n    this.rejectCurrent = () => {};\n  }\n  close() {\n    this.closed = true;\n    this.rejectCurrent(new ConnectionError(new AsyncQueueError('the connection was closed before this query could finish executing')));\n  }\n  enqueue(asyncFunction) {\n    // This outer promise might seems superflous since down below we return asyncFunction().then(resolve, reject).\n    // However, this ensures that this.previous will never be a rejected promise so the queue will\n    // always keep going, while still communicating rejection from asyncFunction to the user.\n    return new Promise((resolve, reject) => {\n      this.previous = this.previous.then(\n        () => {\n          this.rejectCurrent = reject;\n          if (this.closed) {\n            return reject(new ConnectionError(new AsyncQueueError('the connection was closed before this query could be executed')));\n          }\n          return asyncFunction().then(resolve, reject);\n        }\n      );\n    });\n  }\n}\n\nexports.default = AsyncQueue;\n"]},"metadata":{},"sourceType":"script"}