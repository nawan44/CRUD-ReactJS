{"ast":null,"code":"'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\n\nconst SequelizeErrors = require('../../errors');\n\nconst {\n  logger\n} = require('../../utils/logger');\n\nconst DataTypes = require('../../data-types').mysql;\n\nconst momentTz = require('moment-timezone');\n\nconst debug = logger.debugContext('connection:mysql');\n\nconst parserStore = require('../parserStore')('mysql');\n\nconst {\n  promisify\n} = require('util');\n/**\n * MySQL Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle MySQL specific connections\n * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server\n *\n * @private\n */\n\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('mysql2');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n\n    return next();\n  }\n  /**\n   * Connect with MySQL database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n\n\n  async connect(config) {\n    const connectionConfig = {\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      flags: '-FOUND_ROWS',\n      password: config.password,\n      database: config.database,\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true,\n      ...config.dialectOptions\n    };\n\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection = this.lib.createConnection(connectionConfig);\n\n        const errorHandler = e => {\n          // clean up connect & error event if there is error\n          connection.removeListener('connect', connectHandler);\n          connection.removeListener('error', connectHandler);\n          reject(e);\n        };\n\n        const connectHandler = () => {\n          // clean up error event if connected\n          connection.removeListener('error', errorHandler);\n          resolve(connection);\n        }; // don't use connection.once for error event handling here\n        // mysql2 emit error two times in case handshake was failed\n        // first error is protocol_lost and second is timeout\n        // if we will use `once.error` node process will crash on 2nd error emit\n\n\n        connection.on('error', errorHandler);\n        connection.once('connect', connectHandler);\n      });\n      debug('connection acquired');\n      connection.on('error', error => {\n        switch (error.code) {\n          case 'ESOCKET':\n          case 'ECONNRESET':\n          case 'EPIPE':\n          case 'PROTOCOL_CONNECTION_LOST':\n            this.pool.destroy(connection);\n        }\n      });\n\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        // set timezone for this connection\n        // but named timezone are not directly supported in mysql, so get its offset first\n        let tzOffset = this.sequelize.options.timezone;\n        tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;\n        await promisify(cb => connection.query(`SET time_zone = '${tzOffset}'`, cb))();\n      }\n\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case 'ECONNREFUSED':\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n\n        case 'ER_ACCESS_DENIED_ERROR':\n          throw new SequelizeErrors.AccessDeniedError(err);\n\n        case 'ENOTFOUND':\n          throw new SequelizeErrors.HostNotFoundError(err);\n\n        case 'EHOSTUNREACH':\n          throw new SequelizeErrors.HostNotReachableError(err);\n\n        case 'EINVAL':\n          throw new SequelizeErrors.InvalidConnectionError(err);\n\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    // Don't disconnect connections with CLOSED state\n    if (connection._closing) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return;\n    }\n\n    return await promisify(callback => connection.end(callback))();\n  }\n\n  validate(connection) {\n    return connection && !connection._fatalError && !connection._protocolError && !connection._closing && !connection.stream.destroyed;\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"sources":["/home/nawan44/Documents/github/portofolio/CRUD/node_modules/sequelize/lib/dialects/mysql/connection-manager.js"],"names":["AbstractConnectionManager","require","SequelizeErrors","logger","DataTypes","mysql","momentTz","debug","debugContext","parserStore","promisify","ConnectionManager","constructor","dialect","sequelize","config","port","lib","_loadDialectModule","refreshTypeParser","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","_typecast","field","next","get","type","options","connect","connectionConfig","host","user","username","flags","password","database","timezone","typeCast","bind","bigNumberStrings","supportBigNumbers","dialectOptions","connection","Promise","resolve","reject","createConnection","errorHandler","e","removeListener","connectHandler","on","once","error","code","pool","destroy","keepDefaultTimezone","tzOffset","test","tz","format","cb","query","err","ConnectionRefusedError","AccessDeniedError","HostNotFoundError","HostNotReachableError","InvalidConnectionError","ConnectionError","disconnect","_closing","callback","end","validate","_fatalError","_protocolError","stream","destroyed","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst SequelizeErrors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst DataTypes = require('../../data-types').mysql;\nconst momentTz = require('moment-timezone');\nconst debug = logger.debugContext('connection:mysql');\nconst parserStore = require('../parserStore')('mysql');\nconst { promisify } = require('util');\n\n/**\n * MySQL Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle MySQL specific connections\n * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server\n *\n * @private\n */\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('mysql2');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  /**\n   * Connect with MySQL database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  async connect(config) {\n    const connectionConfig = {\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      flags: '-FOUND_ROWS',\n      password: config.password,\n      database: config.database,\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true,\n      ...config.dialectOptions\n    };\n\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection = this.lib.createConnection(connectionConfig);\n\n        const errorHandler = e => {\n          // clean up connect & error event if there is error\n          connection.removeListener('connect', connectHandler);\n          connection.removeListener('error', connectHandler);\n          reject(e);\n        };\n\n        const connectHandler = () => {\n          // clean up error event if connected\n          connection.removeListener('error', errorHandler);\n          resolve(connection);\n        };\n\n        // don't use connection.once for error event handling here\n        // mysql2 emit error two times in case handshake was failed\n        // first error is protocol_lost and second is timeout\n        // if we will use `once.error` node process will crash on 2nd error emit\n        connection.on('error', errorHandler);\n        connection.once('connect', connectHandler);\n      });\n\n      debug('connection acquired');\n      connection.on('error', error => {\n        switch (error.code) {\n          case 'ESOCKET':\n          case 'ECONNRESET':\n          case 'EPIPE':\n          case 'PROTOCOL_CONNECTION_LOST':\n            this.pool.destroy(connection);\n        }\n      });\n\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        // set timezone for this connection\n        // but named timezone are not directly supported in mysql, so get its offset first\n        let tzOffset = this.sequelize.options.timezone;\n        tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;\n        await promisify(cb => connection.query(`SET time_zone = '${tzOffset}'`, cb))();\n      }\n\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case 'ECONNREFUSED':\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case 'ER_ACCESS_DENIED_ERROR':\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case 'ENOTFOUND':\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case 'EHOSTUNREACH':\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case 'EINVAL':\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    // Don't disconnect connections with CLOSED state\n    if (connection._closing) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return;\n    }\n\n    return await promisify(callback => connection.end(callback))();\n  }\n\n  validate(connection) {\n    return connection\n      && !connection._fatalError\n      && !connection._protocolError\n      && !connection._closing\n      && !connection.stream.destroyed;\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}