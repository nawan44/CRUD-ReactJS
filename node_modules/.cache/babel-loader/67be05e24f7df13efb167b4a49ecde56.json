{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\n\nconst {\n  logger\n} = require('../../utils/logger');\n\nconst debug = logger.debugContext('connection:sqlite');\n\nconst dataTypes = require('../../data-types').sqlite;\n\nconst sequelizeErrors = require('../../errors');\n\nconst parserStore = require('../parserStore')('sqlite');\n\nconst {\n  promisify\n} = require('util');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize); // We attempt to parse file location from a connection uri\n    // but we shouldn't match sequelize default host.\n\n    if (this.sequelize.options.host === 'localhost') {\n      delete this.sequelize.options.host;\n    }\n\n    this.connections = {};\n    this.lib = this._loadDialectModule('sqlite3');\n    this.refreshTypeParser(dataTypes);\n  }\n\n  async _onProcessExit() {\n    await Promise.all(Object.getOwnPropertyNames(this.connections).map(connection => promisify(callback => this.connections[connection].close(callback))()));\n    return super._onProcessExit.call(this);\n  } // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || 'default';\n    options.storage = this.sequelize.options.storage || this.sequelize.options.host || ':memory:';\n    options.inMemory = options.storage === ':memory:' ? 1 : 0;\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;\n    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;\n\n    if (this.connections[options.inMemory || options.uuid]) {\n      return this.connections[options.inMemory || options.uuid];\n    }\n\n    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {\n      // automatic path provision for `options.storage`\n      fs.mkdirSync(path.dirname(options.storage), {\n        recursive: true\n      });\n    }\n\n    const connection = await new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(options.storage, options.readWriteMode, err => {\n        if (err) return reject(new sequelizeErrors.ConnectionError(err));\n        debug(`connection acquired ${options.uuid}`);\n        resolve(this.connections[options.inMemory || options.uuid]);\n      });\n    });\n\n    if (this.sequelize.config.password) {\n      // Make it possible to define and use password for sqlite encryption plugin like sqlcipher\n      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);\n    }\n\n    if (this.sequelize.options.foreignKeys !== false) {\n      // Make it possible to define and use foreign key constraints unless\n      // explicitly disallowed. It's still opt-in per relation\n      connection.run('PRAGMA FOREIGN_KEYS=ON');\n    }\n\n    return connection;\n  }\n\n  releaseConnection(connection, force) {\n    if (connection.filename === ':memory:' && force !== true) return;\n\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"sources":["/home/nawan44/Documents/github/portofolio/CRUD/node_modules/sequelize/lib/dialects/sqlite/connection-manager.js"],"names":["fs","require","path","AbstractConnectionManager","logger","debug","debugContext","dataTypes","sqlite","sequelizeErrors","parserStore","promisify","ConnectionManager","constructor","dialect","sequelize","options","host","connections","lib","_loadDialectModule","refreshTypeParser","_onProcessExit","Promise","all","Object","getOwnPropertyNames","map","connection","callback","close","call","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","getConnection","uuid","storage","inMemory","dialectOptions","defaultReadWriteMode","OPEN_READWRITE","OPEN_CREATE","readWriteMode","mode","mkdirSync","dirname","recursive","resolve","reject","Database","err","ConnectionError","config","password","run","escape","foreignKeys","releaseConnection","force","filename","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst { logger } = require('../../utils/logger');\nconst debug = logger.debugContext('connection:sqlite');\nconst dataTypes = require('../../data-types').sqlite;\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\nconst { promisify } = require('util');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    // We attempt to parse file location from a connection uri\n    // but we shouldn't match sequelize default host.\n    if (this.sequelize.options.host === 'localhost') {\n      delete this.sequelize.options.host;\n    }\n\n    this.connections = {};\n    this.lib = this._loadDialectModule('sqlite3');\n    this.refreshTypeParser(dataTypes);\n  }\n\n  async _onProcessExit() {\n    await Promise.all(\n      Object.getOwnPropertyNames(this.connections)\n        .map(connection => promisify(callback => this.connections[connection].close(callback))())\n    );\n    return super._onProcessExit.call(this);\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || 'default';\n    options.storage = this.sequelize.options.storage || this.sequelize.options.host || ':memory:';\n    options.inMemory = options.storage === ':memory:' ? 1 : 0;\n\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;\n\n    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;\n\n    if (this.connections[options.inMemory || options.uuid]) {\n      return this.connections[options.inMemory || options.uuid];\n    }\n\n    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {\n      // automatic path provision for `options.storage`\n      fs.mkdirSync(path.dirname(options.storage), { recursive: true });\n    }\n\n    const connection = await new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(\n        options.storage,\n        options.readWriteMode,\n        err => {\n          if (err) return reject(new sequelizeErrors.ConnectionError(err));\n          debug(`connection acquired ${options.uuid}`);\n          resolve(this.connections[options.inMemory || options.uuid]);\n        }\n      );\n    });\n\n    if (this.sequelize.config.password) {\n      // Make it possible to define and use password for sqlite encryption plugin like sqlcipher\n      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);\n    }\n    if (this.sequelize.options.foreignKeys !== false) {\n      // Make it possible to define and use foreign key constraints unless\n      // explicitly disallowed. It's still opt-in per relation\n      connection.run('PRAGMA FOREIGN_KEYS=ON');\n    }\n\n    return connection;\n  }\n\n  releaseConnection(connection, force) {\n    if (connection.filename === ':memory:' && force !== true) return;\n\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}