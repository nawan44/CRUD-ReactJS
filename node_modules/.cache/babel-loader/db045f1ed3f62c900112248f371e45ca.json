{"ast":null,"code":"'use strict';\n\nconst {\n  Pool,\n  TimeoutError\n} = require('sequelize-pool');\n\nconst _ = require('lodash');\n\nconst semver = require('semver');\n\nconst errors = require('../../errors');\n\nconst {\n  logger\n} = require('../../utils/logger');\n\nconst deprecations = require('../../utils/deprecations');\n\nconst debug = logger.debugContext('pool');\n/**\n * Abstract Connection Manager\n *\n * Connection manager which handles pooling & replication.\n * Uses sequelize-pool for pooling\n *\n * @private\n */\n\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 10000,\n      acquire: 60000,\n      evict: 1000,\n      validate: this._validate.bind(this)\n    });\n    this.initPools();\n  }\n\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);\n        }\n      }\n    });\n  }\n  /**\n   * Try to load dialect module from various configured options.\n   * Priority goes like dialectModulePath > dialectModule > require(default)\n   *\n   * @param {string} moduleName Name of dialect module to lookup\n   *\n   * @private\n   * @returns {object}\n   */\n\n\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return require(this.sequelize.config.dialectModulePath);\n      }\n\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      }\n\n      return require(moduleName);\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);\n        }\n\n        throw new Error(`Please install ${moduleName} package manually`);\n      }\n\n      throw err;\n    }\n  }\n  /**\n   * Handler which executes on process exit or connection manager shutdown\n   *\n   * @private\n   * @returns {Promise}\n   */\n\n\n  async _onProcessExit() {\n    if (!this.pool) {\n      return;\n    }\n\n    await this.pool.drain();\n    debug('connection drain due to process exit');\n    return await this.pool.destroyAllNow();\n  }\n  /**\n   * Drain the pool and close it permanently\n   *\n   * @returns {Promise}\n   */\n\n\n  async close() {\n    // Mark close of pool\n    this.getConnection = async function getConnection() {\n      throw new Error('ConnectionManager.getConnection was called after the connection manager was closed!');\n    };\n\n    return await this._onProcessExit();\n  }\n  /**\n   * Initialize connection pool. By default pool autostart is set to false, so no connection will be\n   * be created unless `pool.acquire` is called.\n   */\n\n\n  initPools() {\n    const config = this.config;\n\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: 'sequelize',\n        create: () => this._connect(config),\n        destroy: async connection => {\n          const result = await this._disconnect(connection);\n          debug('connection destroy');\n          return result;\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      });\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n      return;\n    }\n\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    } // Map main connection config\n\n\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication')); // Apply defaults to each read config\n\n    config.replication.read = config.replication.read.map(readConfig => _.defaults(readConfig, _.omit(this.config, 'replication'))); // custom pooling for replication (original author @janmeier)\n\n    let reads = 0;\n    this.pool = {\n      release: client => {\n        if (client.queryType === 'read') {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === undefined ? false : useMaster;\n\n        if (queryType === 'SELECT' && !useMaster) {\n          return this.pool.read.acquire();\n        }\n\n        return this.pool.write.acquire();\n      },\n      destroy: connection => {\n        this.pool[connection.queryType].destroy(connection);\n        debug('connection destroy');\n      },\n      destroyAllNow: async () => {\n        await Promise.all([this.pool.read.destroyAllNow(), this.pool.write.destroyAllNow()]);\n        debug('all connections destroyed');\n      },\n      drain: async () => Promise.all([this.pool.write.drain(), this.pool.read.drain()]),\n      read: new Pool({\n        name: 'sequelize:read',\n        create: async () => {\n          // round robin config\n          const nextRead = reads++ % config.replication.read.length;\n          const connection = await this._connect(config.replication.read[nextRead]);\n          connection.queryType = 'read';\n          return connection;\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      }),\n      write: new Pool({\n        name: 'sequelize:write',\n        create: async () => {\n          const connection = await this._connect(config.replication.write);\n          connection.queryType = 'write';\n          return connection;\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      })\n    };\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n  /**\n   * Get connection from pool. It sets database version if it's not already set.\n   * Call pool.acquire to get a connection\n   *\n   * @param {object}   [options]                 Pool options\n   * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`\n   * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from\n   *\n   * @returns {Promise<Connection>}\n   */\n\n\n  async getConnection(options) {\n    options = options || {};\n\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (!this.versionPromise) {\n        this.versionPromise = (async () => {\n          try {\n            const connection = await this._connect(this.config.replication.write || this.config);\n            const _options = {};\n            _options.transaction = {\n              connection\n            }; // Cheat .query to use our private connection\n\n            _options.logging = () => {};\n\n            _options.logging.__testLoggingFn = true; //connection might have set databaseVersion value at initialization,\n            //avoiding a useless round trip\n\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = await this.sequelize.databaseVersion(_options);\n              const parsedVersion = _.get(semver.coerce(version), 'version') || version;\n              this.sequelize.options.databaseVersion = semver.valid(parsedVersion) ? parsedVersion : this.dialect.defaultVersion;\n            }\n\n            if (semver.lt(this.sequelize.options.databaseVersion, this.dialect.defaultVersion)) {\n              deprecations.unsupportedEngine();\n              debug(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`);\n            }\n\n            this.versionPromise = null;\n            return await this._disconnect(connection);\n          } catch (err) {\n            this.versionPromise = null;\n            throw err;\n          }\n        })();\n      }\n\n      await this.versionPromise;\n    }\n\n    let result;\n\n    try {\n      result = await this.pool.acquire(options.type, options.useMaster);\n    } catch (error) {\n      if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);\n      throw error;\n    }\n\n    debug('connection acquired');\n    return result;\n  }\n  /**\n   * Release a pooled connection so it can be utilized by other connection requests\n   *\n   * @param {Connection} connection\n   *\n   * @returns {Promise}\n   */\n\n\n  async releaseConnection(connection) {\n    this.pool.release(connection);\n    debug('connection released');\n  }\n  /**\n   * Call dialect library to get connection\n   *\n   * @param {*} config Connection config\n   * @private\n   * @returns {Promise<Connection>}\n   */\n\n\n  async _connect(config) {\n    await this.sequelize.runHooks('beforeConnect', config);\n    const connection = await this.dialect.connectionManager.connect(config);\n    await this.sequelize.runHooks('afterConnect', connection, config);\n    return connection;\n  }\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @returns {Promise}\n   */\n\n\n  async _disconnect(connection) {\n    await this.sequelize.runHooks('beforeDisconnect', connection);\n    await this.dialect.connectionManager.disconnect(connection);\n    return this.sequelize.runHooks('afterDisconnect', connection);\n  }\n  /**\n   * Determine if a connection is still valid or not\n   *\n   * @param {Connection} connection\n   *\n   * @returns {boolean}\n   */\n\n\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n\n    return this.dialect.connectionManager.validate(connection);\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"sources":["/home/nawan44/Documents/github/portofolio/CRUD/node_modules/sequelize/lib/dialects/abstract/connection-manager.js"],"names":["Pool","TimeoutError","require","_","semver","errors","logger","deprecations","debug","debugContext","ConnectionManager","constructor","dialect","sequelize","config","cloneDeep","versionPromise","dialectName","options","pool","Error","defaults","max","min","idle","acquire","evict","validate","_validate","bind","initPools","refreshTypeParser","dataTypes","each","dataType","Object","prototype","hasOwnProperty","call","types","_refreshTypeParser","key","_loadDialectModule","moduleName","dialectModulePath","dialectModule","err","code","_onProcessExit","drain","destroyAllNow","close","getConnection","replication","name","create","_connect","destroy","connection","result","_disconnect","acquireTimeoutMillis","idleTimeoutMillis","reapIntervalMillis","maxUses","Array","isArray","read","write","omit","map","readConfig","reads","release","client","queryType","useMaster","undefined","Promise","all","nextRead","length","databaseVersion","_options","transaction","logging","__testLoggingFn","version","parsedVersion","get","coerce","valid","defaultVersion","lt","unsupportedEngine","type","error","ConnectionAcquireTimeoutError","releaseConnection","runHooks","connectionManager","connect","disconnect","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { Pool, TimeoutError } = require('sequelize-pool');\nconst _ = require('lodash');\nconst semver = require('semver');\nconst errors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst deprecations = require('../../utils/deprecations');\nconst debug = logger.debugContext('pool');\n\n/**\n * Abstract Connection Manager\n *\n * Connection manager which handles pooling & replication.\n * Uses sequelize-pool for pooling\n *\n * @private\n */\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 10000,\n      acquire: 60000,\n      evict: 1000,\n      validate: this._validate.bind(this)\n    });\n\n    this.initPools();\n  }\n\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);\n        }\n      }\n    });\n  }\n\n  /**\n   * Try to load dialect module from various configured options.\n   * Priority goes like dialectModulePath > dialectModule > require(default)\n   *\n   * @param {string} moduleName Name of dialect module to lookup\n   *\n   * @private\n   * @returns {object}\n   */\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return require(this.sequelize.config.dialectModulePath);\n      }\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      }\n      return require(moduleName);\n\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);\n        }\n        throw new Error(`Please install ${moduleName} package manually`);\n      }\n\n      throw err;\n    }\n  }\n\n  /**\n   * Handler which executes on process exit or connection manager shutdown\n   *\n   * @private\n   * @returns {Promise}\n   */\n  async _onProcessExit() {\n    if (!this.pool) {\n      return;\n    }\n\n    await this.pool.drain();\n    debug('connection drain due to process exit');\n\n    return await this.pool.destroyAllNow();\n  }\n\n  /**\n   * Drain the pool and close it permanently\n   *\n   * @returns {Promise}\n   */\n  async close() {\n    // Mark close of pool\n    this.getConnection = async function getConnection() {\n      throw new Error('ConnectionManager.getConnection was called after the connection manager was closed!');\n    };\n\n    return await this._onProcessExit();\n  }\n\n  /**\n   * Initialize connection pool. By default pool autostart is set to false, so no connection will be\n   * be created unless `pool.acquire` is called.\n   */\n  initPools() {\n    const config = this.config;\n\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: 'sequelize',\n        create: () => this._connect(config),\n        destroy: async connection => {\n          const result = await this._disconnect(connection);\n          debug('connection destroy');\n          return result;\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      });\n\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n\n      return;\n    }\n\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    }\n\n    // Map main connection config\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication'));\n\n    // Apply defaults to each read config\n    config.replication.read = config.replication.read.map(readConfig =>\n      _.defaults(readConfig, _.omit(this.config, 'replication'))\n    );\n\n    // custom pooling for replication (original author @janmeier)\n    let reads = 0;\n    this.pool = {\n      release: client => {\n        if (client.queryType === 'read') {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === undefined ? false : useMaster;\n        if (queryType === 'SELECT' && !useMaster) {\n          return this.pool.read.acquire();\n        }\n        return this.pool.write.acquire();\n      },\n      destroy: connection => {\n        this.pool[connection.queryType].destroy(connection);\n        debug('connection destroy');\n      },\n      destroyAllNow: async () => {\n        await Promise.all([\n          this.pool.read.destroyAllNow(),\n          this.pool.write.destroyAllNow()\n        ]);\n\n        debug('all connections destroyed');\n      },\n      drain: async () => Promise.all([\n        this.pool.write.drain(),\n        this.pool.read.drain()\n      ]),\n      read: new Pool({\n        name: 'sequelize:read',\n        create: async () => {\n          // round robin config\n          const nextRead = reads++ % config.replication.read.length;\n          const connection = await this._connect(config.replication.read[nextRead]);\n          connection.queryType = 'read';\n          return connection;\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      }),\n      write: new Pool({\n        name: 'sequelize:write',\n        create: async () => {\n          const connection = await this._connect(config.replication.write);\n          connection.queryType = 'write';\n          return connection;\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      })\n    };\n\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n\n  /**\n   * Get connection from pool. It sets database version if it's not already set.\n   * Call pool.acquire to get a connection\n   *\n   * @param {object}   [options]                 Pool options\n   * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`\n   * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from\n   *\n   * @returns {Promise<Connection>}\n   */\n  async getConnection(options) {\n    options = options || {};\n\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (!this.versionPromise) {\n        this.versionPromise = (async () => {\n          try {\n            const connection = await this._connect(this.config.replication.write || this.config);\n            const _options = {};\n\n            _options.transaction = { connection }; // Cheat .query to use our private connection\n            _options.logging = () => {};\n            _options.logging.__testLoggingFn = true;\n\n            //connection might have set databaseVersion value at initialization,\n            //avoiding a useless round trip\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = await this.sequelize.databaseVersion(_options);\n              const parsedVersion = _.get(semver.coerce(version), 'version') || version;\n              this.sequelize.options.databaseVersion = semver.valid(parsedVersion)\n                ? parsedVersion\n                : this.dialect.defaultVersion;\n            }\n\n            if (semver.lt(this.sequelize.options.databaseVersion, this.dialect.defaultVersion)) {\n              deprecations.unsupportedEngine();\n              debug(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`);\n            }\n\n            this.versionPromise = null;\n            return await this._disconnect(connection);\n          } catch (err) {\n            this.versionPromise = null;\n            throw err;\n          }\n        })();\n      }\n      await this.versionPromise;\n    }\n\n    let result;\n\n    try {\n      result = await this.pool.acquire(options.type, options.useMaster);\n    } catch (error) {\n      if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);\n      throw error;\n    }\n\n    debug('connection acquired');\n\n    return result;\n  }\n\n  /**\n   * Release a pooled connection so it can be utilized by other connection requests\n   *\n   * @param {Connection} connection\n   *\n   * @returns {Promise}\n   */\n  async releaseConnection(connection) {\n    this.pool.release(connection);\n    debug('connection released');\n  }\n\n  /**\n   * Call dialect library to get connection\n   *\n   * @param {*} config Connection config\n   * @private\n   * @returns {Promise<Connection>}\n   */\n  async _connect(config) {\n    await this.sequelize.runHooks('beforeConnect', config);\n    const connection = await this.dialect.connectionManager.connect(config);\n    await this.sequelize.runHooks('afterConnect', connection, config);\n    return connection;\n  }\n\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @returns {Promise}\n   */\n  async _disconnect(connection) {\n    await this.sequelize.runHooks('beforeDisconnect', connection);\n    await this.dialect.connectionManager.disconnect(connection);\n    return this.sequelize.runHooks('afterDisconnect', connection);\n  }\n\n  /**\n   * Determine if a connection is still valid or not\n   *\n   * @param {Connection} connection\n   *\n   * @returns {boolean}\n   */\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n\n    return this.dialect.connectionManager.validate(connection);\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}