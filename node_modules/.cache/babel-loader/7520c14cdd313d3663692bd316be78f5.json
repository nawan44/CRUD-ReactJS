{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\n\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nconst util = require('util');\n\nconst Op = require('../../operators');\n\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = ['CONSTRAINT_NAME as constraint_name', 'CONSTRAINT_NAME as constraintName', 'CONSTRAINT_SCHEMA as constraintSchema', 'CONSTRAINT_SCHEMA as constraintCatalog', 'TABLE_NAME as tableName', 'TABLE_SCHEMA as tableSchema', 'TABLE_SCHEMA as tableCatalog', 'COLUMN_NAME as columnName', 'REFERENCED_TABLE_SCHEMA as referencedTableSchema', 'REFERENCED_TABLE_SCHEMA as referencedTableCatalog', 'REFERENCED_TABLE_NAME as referencedTableName', 'REFERENCED_COLUMN_NAME as referencedColumnName'].join(',');\nconst typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = { ...this.OperatorMap,\n      [Op.regexp]: 'REGEXP',\n      [Op.notRegexp]: 'NOT REGEXP'\n    };\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = {\n      charset: null,\n      collate: null,\n      ...options\n    };\n    return Utils.joinSQLFragments(['CREATE DATABASE IF NOT EXISTS', this.quoteIdentifier(databaseName), options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`, options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`, ';']);\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n\n  createSchema() {\n    return 'SHOW TABLES';\n  }\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  }\n\n  versionQuery() {\n    return 'SELECT VERSION() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = {\n      engine: 'InnoDB',\n      charset: null,\n      rowFormat: null,\n      ...options\n    };\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes('REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // MySQL doesn't support inline REFERENCES declarations: move to the end\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return Utils.joinSQLFragments(['CREATE TABLE IF NOT EXISTS', table, `(${attributesClause})`, `ENGINE=${options.engine}`, options.comment && typeof options.comment === 'string' && `COMMENT ${this.escape(options.comment)}`, options.charset && `DEFAULT CHARSET=${options.charset}`, options.collate && `COLLATE ${options.collate}`, options.initialAutoIncrement && `AUTO_INCREMENT=${options.initialAutoIncrement}`, options.rowFormat && `ROW_FORMAT=${options.rowFormat}`, ';']);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery(database) {\n    let query = 'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'';\n\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += ' AND TABLE_SCHEMA NOT IN (\\'MYSQL\\', \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\', \\'SYS\\')';\n    }\n\n    return `${query};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments(['ALTER TABLE', this.quoteTable(table), 'ADD', this.quoteIdentifier(key), this.attributeToSQL(dataType, {\n      context: 'addColumn',\n      tableName: table,\n      foreignKey: key\n    }), ';']);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments(['ALTER TABLE', this.quoteTable(tableName), 'DROP', this.quoteIdentifier(attributeName), ';']);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n\n      if (definition.includes('REFERENCES')) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\\`${attributeName}\\` \\`${attributeName}\\` ${definition}`);\n      }\n    }\n\n    return Utils.joinSQLFragments(['ALTER TABLE', this.quoteTable(tableName), attrString.length && `CHANGE ${attrString.join(', ')}`, constraintString.length && `ADD ${constraintString.join(', ')}`, ';']);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n\n    return Utils.joinSQLFragments(['ALTER TABLE', this.quoteTable(tableName), 'CHANGE', attrString.join(', '), ';']);\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(' AND ');\n      }\n\n      if (smth.path) {\n        let str; // Allow specifying conditions using the sqlite json functions\n\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        smth.type = 'char';\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = 'decimal';\n      } else if (/text/i.test(smth.type)) {\n        smth.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _toJSONValue(value) {\n    // true/false are stored as strings in mysql\n    if (typeof value === 'boolean') {\n      return value.toString();\n    } // null is stored as a string in mysql\n\n\n    if (value === null) {\n      return 'null';\n    }\n\n    return value;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    let limit = '';\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n\n    if (options.limit) {\n      limit = ` LIMIT ${this.escape(options.limit)}`;\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n\n    if (where) {\n      query += ` WHERE ${where}`;\n    }\n\n    return query + limit;\n  }\n\n  showIndexesQuery(tableName, options) {\n    return Utils.joinSQLFragments([`SHOW INDEX FROM ${this.quoteTable(tableName)}`, options && options.database && `FROM \\`${options.database}\\``]);\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    return Utils.joinSQLFragments(['SELECT CONSTRAINT_CATALOG AS constraintCatalog,', 'CONSTRAINT_NAME AS constraintName,', 'CONSTRAINT_SCHEMA AS constraintSchema,', 'CONSTRAINT_TYPE AS constraintType,', 'TABLE_NAME AS tableName,', 'TABLE_SCHEMA AS tableSchema', 'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS', `WHERE table_name='${tableName}'`, constraintName && `AND constraint_name = '${constraintName}'`, schemaName && `AND TABLE_SCHEMA = '${schemaName}'`, ';']);\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return Utils.joinSQLFragments(['DROP INDEX', this.quoteIdentifier(indexName), 'ON', this.quoteTable(tableName)]);\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({\n      escape: this.escape.bind(this)\n    });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' auto_increment';\n    } // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n\n\n    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if (attribute.references) {\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    } // Check invalid json statement\n\n\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    } // return true if the statement has valid json function\n\n\n    return hasJsonFunction;\n  }\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} schemaName The name of the schema.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments(['SELECT', FOREIGN_KEY_FIELDS, `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`, `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`, 'AND REFERENCED_TABLE_NAME IS NOT NULL', ';']);\n  }\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} columnName The name of the column.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n    return Utils.joinSQLFragments(['SELECT', FOREIGN_KEY_FIELDS, 'FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE', 'WHERE (', [`REFERENCED_TABLE_NAME = ${quotedTableName}`, table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`, `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`], ') OR (', [`TABLE_NAME = ${quotedTableName}`, table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`, `AND COLUMN_NAME = ${quotedColumnName}`, 'AND REFERENCED_TABLE_NAME IS NOT NULL'], ')']);\n  }\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments(['ALTER TABLE', this.quoteTable(tableName), 'DROP FOREIGN KEY', this.quoteIdentifier(foreignKey), ';']);\n  }\n\n} // private methods\n\n\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = MySQLQueryGenerator;","map":{"version":3,"sources":["/home/nawan44/Documents/github/portofolio/CRUD/node_modules/sequelize/lib/dialects/mysql/query-generator.js"],"names":["_","require","Utils","AbstractQueryGenerator","util","Op","JSON_FUNCTION_REGEX","JSON_OPERATOR_REGEX","TOKEN_CAPTURE_REGEX","FOREIGN_KEY_FIELDS","join","typeWithoutDefault","Set","MySQLQueryGenerator","constructor","options","OperatorMap","regexp","notRegexp","createDatabaseQuery","databaseName","charset","collate","joinSQLFragments","quoteIdentifier","escape","dropDatabaseQuery","createSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","engine","rowFormat","primaryKeys","foreignKeys","attrStr","attr","Object","prototype","hasOwnProperty","call","dataType","match","includes","push","replace","table","quoteTable","attributesClause","pkString","map","pk","uniqueKeys","each","columns","indexName","customIndex","fields","field","length","fkey","comment","initialAutoIncrement","describeTableQuery","schema","schemaDelimiter","addSchema","_schema","_schemaDelimiter","showTablesQuery","database","query","addColumnQuery","key","attributeToSQL","context","foreignKey","removeColumnQuery","attributeName","changeColumnQuery","attrString","constraintString","definition","attrName","renameColumnQuery","attrBefore","handleSequelizeMethod","smth","factory","prepend","Json","conditions","parseConditionObject","condition","jsonPathExtractionQuery","path","tail","value","str","_checkValidJsonStatement","paths","toPath","column","shift","format","Cast","test","type","json","_toJSONValue","toString","truncateTableQuery","deleteQuery","where","model","limit","getWhereConditions","showIndexesQuery","showConstraintsQuery","constraintName","schemaName","removeIndexQuery","indexNameOrAttributes","underscore","attribute","isPlainObject","attributeString","bind","template","allowNull","autoIncrement","has","_binary","defaultValueSchemable","defaultValue","unique","primaryKey","first","after","references","fkName","onDelete","toUpperCase","onUpdate","attributesToSQL","result","stmt","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","substr","functionMatches","exec","indexOf","operatorMatches","tokenMatches","capturedToken","Error","getForeignKeysQuery","getForeignKeyQuery","columnName","quotedSchemaName","wrapSingleQuote","quotedTableName","quotedColumnName","dropForeignKeyQuery","identifier","addTicks","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst util = require('util');\nconst Op = require('../../operators');\n\n\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\n  'CONSTRAINT_NAME as constraint_name',\n  'CONSTRAINT_NAME as constraintName',\n  'CONSTRAINT_SCHEMA as constraintSchema',\n  'CONSTRAINT_SCHEMA as constraintCatalog',\n  'TABLE_NAME as tableName',\n  'TABLE_SCHEMA as tableSchema',\n  'TABLE_SCHEMA as tableCatalog',\n  'COLUMN_NAME as columnName',\n  'REFERENCED_TABLE_SCHEMA as referencedTableSchema',\n  'REFERENCED_TABLE_SCHEMA as referencedTableCatalog',\n  'REFERENCED_TABLE_NAME as referencedTableName',\n  'REFERENCED_COLUMN_NAME as referencedColumnName'\n].join(',');\n\nconst typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n\n    this.OperatorMap = {\n      ...this.OperatorMap,\n      [Op.regexp]: 'REGEXP',\n      [Op.notRegexp]: 'NOT REGEXP'\n    };\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = {\n      charset: null,\n      collate: null,\n      ...options\n    };\n\n    return Utils.joinSQLFragments([\n      'CREATE DATABASE IF NOT EXISTS',\n      this.quoteIdentifier(databaseName),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      ';'\n    ]);\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n\n  createSchema() {\n    return 'SHOW TABLES';\n  }\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  }\n\n  versionQuery() {\n    return 'SELECT VERSION() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = {\n      engine: 'InnoDB',\n      charset: null,\n      rowFormat: null,\n      ...options\n    };\n\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes('REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // MySQL doesn't support inline REFERENCES declarations: move to the end\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'CREATE TABLE IF NOT EXISTS',\n      table,\n      `(${attributesClause})`,\n      `ENGINE=${options.engine}`,\n      options.comment && typeof options.comment === 'string' && `COMMENT ${this.escape(options.comment)}`,\n      options.charset && `DEFAULT CHARSET=${options.charset}`,\n      options.collate && `COLLATE ${options.collate}`,\n      options.initialAutoIncrement && `AUTO_INCREMENT=${options.initialAutoIncrement}`,\n      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,\n      ';'\n    ]);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery(database) {\n    let query = 'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'';\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += ' AND TABLE_SCHEMA NOT IN (\\'MYSQL\\', \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\', \\'SYS\\')';\n    }\n    return `${query};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        context: 'addColumn',\n        tableName: table,\n        foreignKey: key\n      }),\n      ';'\n    ]);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP',\n      this.quoteIdentifier(attributeName),\n      ';'\n    ]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n      if (definition.includes('REFERENCES')) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\\`${attributeName}\\` \\`${attributeName}\\` ${definition}`);\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      attrString.length && `CHANGE ${attrString.join(', ')}`,\n      constraintString.length && `ADD ${constraintString.join(', ')}`,\n      ';'\n    ]);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'CHANGE',\n      attrString.join(', '),\n      ';'\n    ]);\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        smth.type = 'char';\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = 'decimal';\n      } else if (/text/i.test(smth.type)) {\n        smth.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _toJSONValue(value) {\n    // true/false are stored as strings in mysql\n    if (typeof value === 'boolean') {\n      return value.toString();\n    }\n    // null is stored as a string in mysql\n    if (value === null) {\n      return 'null';\n    }\n    return value;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    let limit = '';\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n\n    if (options.limit) {\n      limit = ` LIMIT ${this.escape(options.limit)}`;\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n\n    if (where) {\n      query += ` WHERE ${where}`;\n    }\n\n    return query + limit;\n  }\n\n  showIndexesQuery(tableName, options) {\n    return Utils.joinSQLFragments([\n      `SHOW INDEX FROM ${this.quoteTable(tableName)}`,\n      options && options.database && `FROM \\`${options.database}\\``\n    ]);\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n\n    return Utils.joinSQLFragments([\n      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',\n      'CONSTRAINT_NAME AS constraintName,',\n      'CONSTRAINT_SCHEMA AS constraintSchema,',\n      'CONSTRAINT_TYPE AS constraintType,',\n      'TABLE_NAME AS tableName,',\n      'TABLE_SCHEMA AS tableSchema',\n      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',\n      `WHERE table_name='${tableName}'`,\n      constraintName && `AND constraint_name = '${constraintName}'`,\n      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,\n      ';'\n    ]);\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'DROP INDEX',\n      this.quoteIdentifier(indexName),\n      'ON',\n      this.quoteTable(tableName)\n    ]);\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' auto_increment';\n    }\n\n    // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n    if (!typeWithoutDefault.has(attributeString)\n      && attribute.type._binary !== true\n      && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if (attribute.references) {\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} schemaName The name of the schema.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      'SELECT',\n      FOREIGN_KEY_FIELDS,\n      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,\n      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,\n      'AND REFERENCED_TABLE_NAME IS NOT NULL',\n      ';'\n    ]);\n  }\n\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} columnName The name of the column.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n\n    return Utils.joinSQLFragments([\n      'SELECT',\n      FOREIGN_KEY_FIELDS,\n      'FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE',\n      'WHERE (',\n      [\n        `REFERENCED_TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`\n      ],\n      ') OR (',\n      [\n        `TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND COLUMN_NAME = ${quotedColumnName}`,\n        'AND REFERENCED_TABLE_NAME IS NOT NULL'\n      ],\n      ')'\n    ]);\n  }\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP FOREIGN KEY',\n      this.quoteIdentifier(foreignKey),\n      ';'\n    ]);\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = MySQLQueryGenerator;\n"]},"metadata":{},"sourceType":"script"}